<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Location Grid with Map Only - Highlight Current Cell</title>
  <!-- LeafletのCSS -->
  <link rel="stylesheet" href="https://unpkg.com/leaflet/dist/leaflet.css" />
  <style>
    body { margin: 0; padding: 0; }
    #map { height: 400px; } /* 地図表示エリアの高さ */
    .accuracy, .position { margin: 10px; }
  </style>
</head>
<body>
  <button onclick="startTracking()">位置測定を開始</button>
  <div class="accuracy"></div>
  <div id="map"></div>
  <div class="position"></div>

  <!-- LeafletのJS -->
  <script src="https://unpkg.com/leaflet/dist/leaflet.js"></script>
  <script>
    let basePosition = null;
    let map;
    let gridOverlayGroup = L.layerGroup(); // 地図上のグリッド用レイヤーグループ
    const CELL_SIZE = 30; // 30メートル四方
    const GRID_SIZE = 8;
    const gridPolygons = []; // 各セルのポリゴンを保存する配列

    function startTracking() {
      if ("geolocation" in navigator) {
        navigator.geolocation.getCurrentPosition(pos => {
          basePosition = {
            lat: pos.coords.latitude,
            lng: pos.coords.longitude
          };

          // Leaflet地図の初期化（ズームレベル19）
          map = L.map('map').setView([basePosition.lat, basePosition.lng], 19);
          L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
            attribution: '© OpenStreetMap contributors'
          }).addTo(map);

          // 30m四方のグリッドオーバーレイを地図上に描画
          drawGridOverlay(basePosition.lat, basePosition.lng);

          // 位置の継続監視を開始
          navigator.geolocation.watchPosition(updatePosition, null, {
            enableHighAccuracy: true,
            timeout: 5000,
            maximumAge: 0
          });
        });
      }
    }

    // 地図上に30m四方のグリッドオーバーレイを描画する関数
    function drawGridOverlay(lat, lng) {
      const metersPerDegree = 111320;
      const latDiff = CELL_SIZE / metersPerDegree;
      const lngDiff = CELL_SIZE / (metersPerDegree * Math.cos(lat * Math.PI / 180));

      // 既存のグリッドをクリア
      gridOverlayGroup.clearLayers();
      gridPolygons.length = 0; // 配列をクリア

      // 基準点を左上とみなして、東（右）方向と南（下）方向に8x8のグリッドを描画
      for (let i = 0; i < GRID_SIZE; i++) {
        for (let j = 0; j < GRID_SIZE; j++) {
          const bounds = [
            [lat - i * latDiff,       lng + j * lngDiff],
            [lat - i * latDiff,       lng + (j + 1) * lngDiff],
            [lat - (i + 1) * latDiff, lng + (j + 1) * lngDiff],
            [lat - (i + 1) * latDiff, lng + j * lngDiff]
          ];
          const polygon = L.polygon(bounds, {
            color: 'black',
            weight: 1,
            fillOpacity: 0.1,
            fillColor: 'gray'
          });
          // セルの位置情報をプロパティに追加
          polygon.gridX = j;
          polygon.gridY = i;
          polygon.addTo(gridOverlayGroup);
          gridPolygons.push(polygon);
        }
      }
      gridOverlayGroup.addTo(map);
    }

    function updatePosition(pos) {
      const accuracy = pos.coords.accuracy;
      const accuracyDiv = document.querySelector('.accuracy');

      // 精度の評価
      let accuracyClass = 'bad';
      let accuracyText = '要注意';
      if (accuracy <= 10) {
        accuracyClass = 'good';
        accuracyText = 'とても良好';
      } else if (accuracy <= 20) {
        accuracyClass = 'normal';
        accuracyText = '普通';
      }
      accuracyDiv.textContent = `精度: ${Math.round(accuracy)}m (${accuracyText})`;

      // 地図上に現在位置のマーカーを表示／更新
      if (!updatePosition.marker) {
        updatePosition.marker = L.marker([pos.coords.latitude, pos.coords.longitude]).addTo(map);
      } else {
        updatePosition.marker.setLatLng([pos.coords.latitude, pos.coords.longitude]);
      }

      // 現在位置をグリッド上のどこにいるかを計算して表示
      const metersPerDegree = 111320;
      const lngDegreePerCell = CELL_SIZE / (metersPerDegree * Math.cos(basePosition.lat * Math.PI / 180));
      const latDegreePerCell = CELL_SIZE / metersPerDegree;
      const deltaLng = pos.coords.longitude - basePosition.lng;
      const deltaLat = basePosition.lat - pos.coords.latitude; // 北上なら正の値

      const gridX = Math.floor(deltaLng / lngDegreePerCell);
      const gridY = Math.floor(deltaLat / latDegreePerCell);

      const positionDiv = document.querySelector('.position');
      if (gridX >= 0 && gridX < GRID_SIZE && gridY >= 0 && gridY < GRID_SIZE) {
        positionDiv.textContent = `現在位置: グリッド(${gridX}, ${gridY})`;
      } else {
        positionDiv.textContent = `現在位置: グリッド外`;
      }

      // グリッドのセルの色を更新（全セルを初期状態にリセット）
      gridPolygons.forEach(polygon => {
        polygon.setStyle({
          fillOpacity: 0.1,
          fillColor: 'gray'
        });
      });
      // 現在のセルがグリッド内なら、そのセルの色を変更してハイライト
      if (gridX >= 0 && gridX < GRID_SIZE && gridY >= 0 && gridY < GRID_SIZE) {
        gridPolygons.forEach(polygon => {
          if (polygon.gridX === gridX && polygon.gridY === gridY) {
            polygon.setStyle({
              fillOpacity: 0.5,
              fillColor: 'blue'
            });
          }
        });
      }
    }
  </script>
</body>
</html>
