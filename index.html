<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Location Grid with Map</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.9.4/leaflet.css" />
    <script src="https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.9.4/leaflet.js"></script>
    <style>
        .container {
            position: relative;
            height: 100vh;
            width: 100%;
            margin: 0;
            padding: 0;
        }
        .controls {
            position: absolute;
            top: 10px;
            left: 10px;
            z-index: 1000;
            background: rgba(255, 255, 255, 0.9);
            padding: 10px;
            border-radius: 4px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
        }
        .accuracy {
            margin: 5px 0;
        }
        .good { color: green; }
        .normal { color: orange; }
        .bad { color: red; }
        #map {
            height: 100%;
            width: 100%;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="controls">
            <button onclick="startTracking()">位置測定を開始</button>
            <div class="accuracy"></div>
            <div class="position"></div>
        </div>
        <div id="map"></div>
    </div>

    <script>
        let basePosition = null;
        let map = null;
        let marker = null;
        let gridLayer = null;
        const GRID_SIZE = 8;
        const CELL_SIZE = 30; // 30メートル

        // 地図の初期化
        function initMap(lat, lng) {
            if (map === null) {
                map = L.map('map').setView([lat, lng], 19);
                L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                    attribution: '© OpenStreetMap contributors'
                }).addTo(map);
                marker = L.marker([lat, lng]).addTo(map);
            } else {
                map.setView([lat, lng], 19);
                marker.setLatLng([lat, lng]);
            }
        }

        // グリッドの作成
        function createGrid(lat, lng) {
            if (gridLayer) {
                map.removeLayer(gridLayer);
            }

            const gridBounds = calculateGridBounds(lat, lng);
            const gridPolygons = [];

            for (let y = 0; y < GRID_SIZE; y++) {
                for (let x = 0; x < GRID_SIZE; x++) {
                    const cellBounds = calculateCellBounds(lat, lng, x, y);
                    const polygon = L.polygon(cellBounds, {
                        color: 'black',
                        weight: 1,
                        fillColor: 'white',
                        fillOpacity: 0.1,
                        className: `grid-cell-${x}-${y}`
                    });
                    gridPolygons.push(polygon);
                }
            }

            gridLayer = L.layerGroup(gridPolygons).addTo(map);
        }

        // グリッドの境界を計算
        function calculateGridBounds(baseLat, baseLng) {
            const latDiff = (CELL_SIZE * GRID_SIZE) / 111320;
            const lngDiff = (CELL_SIZE * GRID_SIZE) / (111320 * Math.cos(baseLat * Math.PI / 180));
            return {
                north: baseLat,
                south: baseLat - latDiff,
                east: baseLng + lngDiff,
                west: baseLng
            };
        }

        // セルの境界を計算
        function calculateCellBounds(baseLat, baseLng, x, y) {
            const latDiff = CELL_SIZE / 111320;
            const lngDiff = CELL_SIZE / (111320 * Math.cos(baseLat * Math.PI / 180));
            
            const north = baseLat - (y * latDiff);
            const south = baseLat - ((y + 1) * latDiff);
            const west = baseLng + (x * lngDiff);
            const east = baseLng + ((x + 1) * lngDiff);

            return [
                [north, west],
                [north, east],
                [south, east],
                [south, west]
            ];
        }

        // セルの色を更新
        function updateCellColor(x, y) {
            document.querySelectorAll('.grid-cell').forEach(el => 
                el.style.fillOpacity = '0.1'
            );
            const targetCell = document.querySelector(`.grid-cell-${x}-${y}`);
            if (targetCell) {
                targetCell.style.fillOpacity = '0.6';
            }
        }

        function startTracking() {
            const button = document.querySelector('button');
            if ("geolocation" in navigator) {
                button.textContent = "位置情報を取得中...";
                button.disabled = true;
                navigator.geolocation.getCurrentPosition(
                    pos => {
                        basePosition = {
                            lat: pos.coords.latitude,
                            lng: pos.coords.longitude
                        };
                        
                        initMap(basePosition.lat, basePosition.lng);
                        createGrid(basePosition.lat, basePosition.lng);
                        
                        navigator.geolocation.watchPosition(updatePosition, null, {
                            enableHighAccuracy: true,
                            timeout: 5000,
                            maximumAge: 0
                        });
                    },
                    (error) => {
                        button.textContent = "位置測定を開始";
                        button.disabled = false;
                        alert("位置情報の取得に失敗しました。設定で位置情報の利用を許可してください。");
                    }
                );
            }
        }

        function updatePosition(pos) {
            const accuracy = pos.coords.accuracy;
            const accuracyDiv = document.querySelector('.accuracy');
            
            let accuracyClass = 'bad';
            let accuracyText = '要注意';
            if (accuracy <= 10) {
                accuracyClass = 'good';
                accuracyText = 'とても良好';
            } else if (accuracy <= 20) {
                accuracyClass = 'normal';
                accuracyText = '普通';
            }
            accuracyDiv.className = `accuracy ${accuracyClass}`;
            accuracyDiv.textContent = `精度: ${Math.round(accuracy)}m (${accuracyText})`;

            const gridX = Math.floor((pos.coords.longitude - basePosition.lng) / (CELL_SIZE / 111320));
            const gridY = Math.floor((pos.coords.latitude - basePosition.lat) / (CELL_SIZE / 111320));

            if (gridX >= 0 && gridX < GRID_SIZE && gridY >= 0 && gridY < GRID_SIZE) {
                updateCellColor(gridX, gridY);
                document.querySelector('.position').textContent = 
                    `現在位置: グリッド(${gridX}, ${gridY})`;
            }

            if (marker) {
                marker.setLatLng([pos.coords.latitude, pos.coords.longitude]);
                map.panTo([pos.coords.latitude, pos.coords.longitude]);
            }
        }
    </script>
</body>
</html>