<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8" />
    <!-- â˜…è¿½åŠ â˜… viewport ã‚’å…ƒã«æˆ»ã™ -->
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />

    <title>ä½ç½®æ¸¬å®šãƒã‚¤ãƒ³ã‚¹ã‚¤ãƒ¼ãƒ‘ãƒ¼ï¼ˆæ”¹è‰¯ç‰ˆï¼šè‡ªåˆ†ã®ä½ç½®ã¯é»„è‰²ï¼‰</title>
    <!-- Leafletã®CSS -->
    <link rel="stylesheet" href="https://unpkg.com/leaflet/dist/leaflet.css" />
    <style>
      body {
        margin: 0;
        padding: 0;
      }
      #map {
        height: 400px;
      }
      .controls {
        margin: 10px;
      }
      .accuracy,
      .position {
        margin: 10px;
      }
      .game-controls {
        margin: 10px;
        display: none;
      }
      /* ãƒªã‚»ãƒƒãƒˆãƒœã‚¿ãƒ³ç”¨ */
      .reset-controls {
        margin: 10px;
        display: none; /* çˆ†å¼¾ã‚’è¸ã‚“ã å¾Œã«è¡¨ç¤º */
      }
      /* ä¸‹éƒ¨ãƒã‚¤ãƒ³ã‚¹ã‚¤ãƒ¼ãƒ‘ãƒ¼ã‚°ãƒªãƒƒãƒ‰è¡¨ç¤º */
      #minesweeperGrid {
        display: block;
        margin: 20px auto;
        width: fit-content;
      }
      .grid-row {
        display: flex;
      }
      .grid-cell {
        width: 30px;
        height: 30px;
        border: 1px solid #999;
        display: flex;
        align-items: center;
        justify-content: center;
        font-weight: bold;
        background-color: #ddd;
      }
      .revealed {
        background-color: rgba(255, 255, 255, 0.5);
      }
      .mine {
        background-color: #f88;
      }
      .flagged {
        background-color: #faa;
      }
      .current-position {
        background-color: yellow !important;
        border: 2px solid gold;
      }
      .number-1 {
        color: blue;
      }
      .number-2 {
        color: green;
      }
      .number-3 {
        color: red;
      }
      .number-4 {
        color: darkblue;
      }
      .number-5 {
        color: darkred;
      }
      .number-6 {
        color: darkcyan;
      }
      .number-7 {
        color: black;
      }
      .number-8 {
        color: gray;
      }
    </style>
  </head>
  <body>
    <div class="controls">
      <label for="cellSizeSelect">ã‚»ãƒ«ã‚µã‚¤ã‚º (m):</label>
      <select id="cellSizeSelect">
        <option value="30">30</option>
        <option value="60">60</option>
        <option value="100" selected>100</option>
        <option value="500">500</option>
        <option value="1000">1000</option>
      </select>

      <label for="gridSizeSelect">ã‚°ãƒªãƒƒãƒ‰ã‚µã‚¤ã‚º:</label>
      <select id="gridSizeSelect">
        <option value="9" selected>9Ã—9</option>
        <option value="17">17Ã—17</option>
        <option value="31">31Ã—31</option>
      </select>

      <button id="getLocationButton" onclick="getLocation()">
        ç¾åœ¨åœ°ã‚’å–å¾—
      </button>
      <button id="startGridButton" onclick="startGrid()" disabled>
        ã‚²ãƒ¼ãƒ ã‚’é–‹å§‹
      </button>
    </div>

    <div class="accuracy"></div>
    <div id="map"></div>
    <div class="position"></div>

    <!-- ã‚²ãƒ¼ãƒ æ“ä½œç”¨ãƒœã‚¿ãƒ³ -->
    <div class="game-controls" id="gameControls">
      <!-- â˜…æ——ãƒœã‚¿ãƒ³ã¯æœ€åˆdisabledã«ã—ã¦ãŠãï¼ˆã‚»ãƒ«ã‚’1ã¤ä»¥ä¸Šé–‹ãã¾ã§ä½¿ãˆãªã„ï¼‰ -->
      <button id="flagButton" disabled>æ——ã‚’ç«‹ã¦ã‚‹</button>
      <button id="openButton" onclick="actionOpen()">é–‹ã</button>
      <button id="resetButton" onclick="resetGame()" style="display: none">
        ãƒªã‚»ãƒƒãƒˆ
      </button>
    </div>

    <!-- ä¸‹éƒ¨ãƒã‚¤ãƒ³ã‚¹ã‚¤ãƒ¼ãƒ‘ãƒ¼ã‚°ãƒªãƒƒãƒ‰è¡¨ç¤º -->
    <div id="minesweeperGrid"></div>

    <!-- Leafletã®JS -->
    <script src="https://unpkg.com/leaflet/dist/leaflet.js"></script>
    <script>
      // URLãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã®ãƒã‚§ãƒƒã‚¯ï¼ˆãƒ‡ãƒãƒƒã‚°ãƒ¢ãƒ¼ãƒ‰ï¼‰
      const urlParams = new URLSearchParams(window.location.search);
      const debugMode = urlParams.get("debug") === "true";

      // ã‚°ãƒ­ãƒ¼ãƒãƒ«å¤‰æ•°
      let basePosition = null;
      let map;
      let gridOverlayGroup = L.layerGroup();
      let CELL_SIZE, GRID_SIZE;
      const gridPolygons = [];
      let topLeftLat, topLeftLng, latDiff, lngDiff;
      let watchId = null;
      let gridFixed = false;
      let currentCell = null;

      // ãƒã‚¤ãƒ³ã‚¹ã‚¤ãƒ¼ãƒ‘ãƒ¼ç”¨å¤‰æ•°
      let mines = [];
      let mineCount = 0;
      let flagsUsed = 0;
      let gameOver = false;
      let gameWon = false;
      let cellsRevealed = 0;
      let minesInitialized = false; // æœ€åˆã®ã‚¯ãƒªãƒƒã‚¯ã§åœ°é›·é…ç½®

      const flagButton = document.getElementById("flagButton");
      const openButton = document.getElementById("openButton");

      // ãƒšãƒ¼ã‚¸èª­ã¿è¾¼ã¿æ™‚
      window.addEventListener("DOMContentLoaded", function () {
        map = L.map("map").setView([35.6895, 139.6917], 10);
        L.tileLayer("https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png", {
          attribution: "Â© OpenStreetMap contributors",
        }).addTo(map);
        gridOverlayGroup.addTo(map);

        // ã‚»ãƒ¬ã‚¯ãƒˆå¤‰æ›´æ™‚ã®æš«å®šæ›´æ–°
        document
          .getElementById("cellSizeSelect")
          .addEventListener("change", updateTentativeGrid);
        document
          .getElementById("gridSizeSelect")
          .addEventListener("change", updateTentativeGrid);

        // æ——ãƒœã‚¿ãƒ³ã®ã‚¯ãƒªãƒƒã‚¯
        flagButton.addEventListener("click", actionFlag);
      });

      // ã€Œç¾åœ¨åœ°ã‚’å–å¾—ã€ãƒœã‚¿ãƒ³
      function getLocation() {
        const getLocationButton = document.getElementById("getLocationButton");
        getLocationButton.textContent = "ä½ç½®æƒ…å ±å–å¾—ä¸­...";
        getLocationButton.disabled = true;

        if ("geolocation" in navigator) {
          navigator.geolocation.getCurrentPosition(
            (pos) => {
              basePosition = {
                lat: pos.coords.latitude,
                lng: pos.coords.longitude,
              };
              map.setView([basePosition.lat, basePosition.lng], 19);

              getLocationButton.textContent = "å ´æ‰€å–å¾—æ¸ˆã¿";
              document.getElementById("startGridButton").disabled = false;

              // æš«å®šã‚°ãƒªãƒƒãƒ‰è¡¨ç¤º
              updateTentativeGrid();

              // watchPositioné–‹å§‹
              if (watchId === null) {
                watchId = navigator.geolocation.watchPosition(
                  updatePosition,
                  null,
                  {
                    enableHighAccuracy: true,
                    timeout: 5000,
                    maximumAge: 0,
                  }
                );
              }
            },
            (err) => {
              getLocationButton.textContent = "å–å¾—å¤±æ•—";
              console.error(err);
            }
          );
        }
      }

      // æš«å®šã‚°ãƒªãƒƒãƒ‰æ›´æ–°
      function updateTentativeGrid() {
        if (!basePosition || gridFixed) return;

        CELL_SIZE = parseInt(
          document.getElementById("cellSizeSelect").value,
          10
        );
        GRID_SIZE = parseInt(
          document.getElementById("gridSizeSelect").value,
          10
        );

        const metersPerDegree = 111320;
        latDiff = CELL_SIZE / metersPerDegree;
        lngDiff =
          CELL_SIZE /
          (metersPerDegree * Math.cos((basePosition.lat * Math.PI) / 180));

        const centerIndex = (GRID_SIZE - 1) / 2;
        topLeftLat = basePosition.lat + (centerIndex + 0.5) * latDiff;
        topLeftLng = basePosition.lng - (centerIndex + 0.5) * lngDiff;

        drawGridOverlay();
      }

      // ã‚°ãƒªãƒƒãƒ‰æç”»
      function drawGridOverlay() {
        gridOverlayGroup.clearLayers();
        gridPolygons.length = 0;

        for (let i = 0; i < GRID_SIZE; i++) {
          for (let j = 0; j < GRID_SIZE; j++) {
            const bounds = [
              [topLeftLat - i * latDiff, topLeftLng + j * lngDiff],
              [topLeftLat - i * latDiff, topLeftLng + (j + 1) * lngDiff],
              [topLeftLat - (i + 1) * latDiff, topLeftLng + (j + 1) * lngDiff],
              [topLeftLat - (i + 1) * latDiff, topLeftLng + j * lngDiff],
            ];
            const polygon = L.polygon(bounds, {
              color: "black",
              weight: 1,
              fillOpacity: 0.1,
              fillColor: "gray",
            });
            polygon.gridX = j;
            polygon.gridY = i;
            polygon.isRevealed = false;
            polygon.isFlagged = false;
            polygon.isMine = false;
            polygon.adjacentMines = 0;
            polygon.addTo(gridOverlayGroup);
            gridPolygons.push(polygon);
          }
        }
      }

      // ã€Œã‚²ãƒ¼ãƒ ã‚’é–‹å§‹ã€ãƒœã‚¿ãƒ³
      function startGrid() {
        gridFixed = true;
        document.getElementById("cellSizeSelect").disabled = true;
        document.getElementById("gridSizeSelect").disabled = true;
        document.getElementById("startGridButton").disabled = true;

        // æ“ä½œUIè¡¨ç¤º
        document.getElementById("gameControls").style.display = "block";

        // ä¸‹éƒ¨UIä½œæˆ
        createMinesweeperGridUI();
      }

      // ä½ç½®æ›´æ–°
      function updatePosition(pos) {
        const accuracy = pos.coords.accuracy;
        const accuracyDiv = document.querySelector(".accuracy");
        let accuracyText = "è¦æ³¨æ„";
        if (accuracy <= 10) {
          accuracyText = "ã¨ã¦ã‚‚è‰¯å¥½";
        } else if (accuracy <= 20) {
          accuracyText = "æ™®é€š";
        }
        accuracyDiv.textContent = `ç²¾åº¦: ${Math.round(
          accuracy
        )}m (${accuracyText})`;

        const deltaLat = topLeftLat - pos.coords.latitude;
        const deltaLng = pos.coords.longitude - topLeftLng;
        const gridY = Math.floor(deltaLat / latDiff);
        const gridX = Math.floor(deltaLng / lngDiff);

        const positionDiv = document.querySelector(".position");
        if (
          gridX >= 0 &&
          gridX < GRID_SIZE &&
          gridY >= 0 &&
          gridY < GRID_SIZE
        ) {
          positionDiv.textContent = `ç¾åœ¨ä½ç½®: ã‚°ãƒªãƒƒãƒ‰(${gridX + 1}, ${
            gridY + 1
          })`;
        } else {
          positionDiv.textContent = "ç¾åœ¨ä½ç½®: ã‚°ãƒªãƒƒãƒ‰å¤–";
        }

        // æœªé–‹å°ãƒ»æœªãƒ•ãƒ©ã‚°ã‚»ãƒ«ã‚’ç°è‰²ã«æˆ»ã™
        gridPolygons.forEach((p) => {
          if (!p.isRevealed && !p.isFlagged) {
            p.setStyle({ fillColor: "gray", fillOpacity: 0.1 });
          }
        });

        let oldCell = currentCell;
        currentCell = null;
        if (
          gridX >= 0 &&
          gridX < GRID_SIZE &&
          gridY >= 0 &&
          gridY < GRID_SIZE
        ) {
          const index = gridY * GRID_SIZE + gridX;
          currentCell = gridPolygons[index];

          // ç¾åœ¨åœ°ã‚»ãƒ«ãŒæœªé–‹å°ãƒ»æœªæ——ãªã‚‰é»„è‰²
          if (
            gridFixed &&
            !gameOver &&
            !currentCell.isRevealed &&
            !currentCell.isFlagged
          ) {
            currentCell.setStyle({ fillColor: "yellow", fillOpacity: 0.5 });
          }
        }

        if (gridFixed && oldCell !== currentCell) {
          updateMinesweeperGridUI();
        }

        // ãƒãƒ¼ã‚«ãƒ¼
        let markerLat, markerLng;
        if (gridFixed && currentCell) {
          markerLat = topLeftLat - (currentCell.gridY + 0.5) * latDiff;
          markerLng = topLeftLng + (currentCell.gridX + 0.5) * lngDiff;
        } else {
          markerLat = pos.coords.latitude;
          markerLng = pos.coords.longitude;
        }
        if (!updatePosition.marker) {
          updatePosition.marker = L.marker([markerLat, markerLng]).addTo(map);
        } else {
          updatePosition.marker.setLatLng([markerLat, markerLng]);
        }
      }

      // ä¸‹éƒ¨ãƒã‚¤ãƒ³ã‚¹ã‚¤ãƒ¼ãƒ‘ãƒ¼ã‚°ãƒªãƒƒãƒ‰UI
      function createMinesweeperGridUI() {
        const container = document.getElementById("minesweeperGrid");
        container.innerHTML = "";

        for (let y = 0; y < GRID_SIZE; y++) {
          const rowDiv = document.createElement("div");
          rowDiv.className = "grid-row";
          for (let x = 0; x < GRID_SIZE; x++) {
            const cellDiv = document.createElement("div");
            cellDiv.className = "grid-cell";
            cellDiv.dataset.x = x;
            cellDiv.dataset.y = y;

            // ãƒ‡ãƒãƒƒã‚°ã‚¯ãƒªãƒƒã‚¯
            if (debugMode) {
              cellDiv.addEventListener("click", () => {
                if (gameOver) return;
                const idx = y * GRID_SIZE + x;
                const poly = gridPolygons[idx];
                if (poly.isRevealed || poly.isFlagged) return;
                if (!minesInitialized) {
                  initializeMinesweeperGame(x, y);
                  minesInitialized = true;
                }
                revealCell(poly);
                if (poly.isMine) {
                  gameOver = true;
                  revealAllMines();
                  updateMinesweeperGridUI();
                  document.getElementById("resetControls").style.display =
                    "block";
                  return;
                }
                if (poly.adjacentMines === 0) {
                  revealAdjacentCells(y, x);
                }
                updateMinesweeperGridUI();
                checkWinCondition();
              });
            }

            rowDiv.appendChild(cellDiv);
          }
          container.appendChild(rowDiv);
        }
        updateMinesweeperGridUI();
      }

      // ä¸‹éƒ¨UIæ›´æ–°
      function updateMinesweeperGridUI() {
        if (!gridFixed) return;
        const cells = document.querySelectorAll(".grid-cell");

        cells.forEach((cell) => {
          const x = parseInt(cell.dataset.x, 10);
          const y = parseInt(cell.dataset.y, 10);
          const index = y * GRID_SIZE + x;
          const polygon = gridPolygons[index];

          cell.className = "grid-cell";
          cell.textContent = "";

          // ç¾åœ¨åœ°
          if (
            currentCell &&
            currentCell.gridX === x &&
            currentCell.gridY === y
          ) {
            cell.classList.add("current-position");
          }

          // é–‹ã„ã¦ã„ã‚‹ã‚»ãƒ«
          if (polygon.isRevealed) {
            cell.classList.add("revealed");
            if (polygon.isMine) {
              cell.classList.add("mine");
              cell.textContent = "ğŸ’£";
            } else if (polygon.adjacentMines > 0) {
              cell.textContent = polygon.adjacentMines;
              cell.classList.add(`number-${polygon.adjacentMines}`);
            }
          }
          // ãƒ•ãƒ©ã‚°
          else if (polygon.isFlagged) {
            cell.classList.add("flagged");
            cell.textContent = "ğŸš©";
          }
        });

        // â˜…æ——ãƒœã‚¿ãƒ³ã®çŠ¶æ…‹ã‚’è¨­å®šï¼ˆ1ã‚»ãƒ«ä»¥ä¸Šé–‹ã„ã¦ã„ãªã„é–“ã¯disabledï¼‰
        if (!currentCell || currentCell.isRevealed || gameOver) {
          // ãƒ•ãƒ©ã‚°æ“ä½œä¸å¯
          flagButton.disabled = true;
          // ä¸€æ—¦ã€Œæ——ã‚’ç«‹ã¦ã‚‹ã€ã«æˆ»ã™
          flagButton.textContent = "æ——ã‚’ç«‹ã¦ã‚‹";
        } else {
          // ã¾ã 1ã¤ã‚‚ã‚»ãƒ«ã‚’é–‹ã„ã¦ãªã„ï¼ˆcellsRevealed === 0ï¼‰ãªã‚‰æ——ä¸å¯
          if (cellsRevealed === 0) {
            flagButton.disabled = true;
            flagButton.textContent = "æ——ã‚’ç«‹ã¦ã‚‹";
          } else {
            // ãƒ•ãƒ©ã‚°æ“ä½œå¯èƒ½
            flagButton.disabled = false;
            // currentCell ãŒæ——ä»˜ãã‹ã©ã†ã‹ã§æ–‡è¨€åˆ‡ã‚Šæ›¿ãˆ
            if (currentCell.isFlagged) {
              flagButton.textContent = "æ——ã‚’æ¶ˆã™";
            } else {
              flagButton.textContent = "æ——ã‚’ç«‹ã¦ã‚‹";
            }
          }
        }
      }

      // æ——åˆ‡ã‚Šæ›¿ãˆ
      function actionFlag() {
        if (!gridFixed || !currentCell || gameOver || currentCell.isRevealed)
          return;
        currentCell.isFlagged = !currentCell.isFlagged;

        if (currentCell.isFlagged) {
          currentCell.setStyle({ fillOpacity: 0.5, fillColor: "red" });
          flagsUsed++;
        } else {
          // å¤–ã—ãŸã‚‰è‡ªåˆ†ã®ã‚»ãƒ«ã¯é»„è‰²ã«æˆ»ã™ï¼ˆæœªé–‹å°ãªã‚‰ï¼‰
          currentCell.setStyle({ fillOpacity: 0.5, fillColor: "yellow" });
          flagsUsed--;
        }

        updateMinesweeperGridUI();
        checkWinCondition();
      }

      // ã‚»ãƒ«ã‚’é–‹ã
      function actionOpen() {
        if (
          !gridFixed ||
          !currentCell ||
          gameOver ||
          currentCell.isRevealed ||
          currentCell.isFlagged
        )
          return;

        // æœ€åˆã®ã‚»ãƒ«ã‚’é–‹ãæ™‚ã«åœ°é›·é…ç½®
        if (!minesInitialized) {
          initializeMinesweeperGame(currentCell.gridX, currentCell.gridY);
          minesInitialized = true;
        }
        revealCell(currentCell);
        if (currentCell.isMine) {
          gameOver = true;
          revealAllMines();
          updateMinesweeperGridUI();
          document.getElementById("resetControls").style.display = "block";
          return;
        }
        if (currentCell.adjacentMines === 0) {
          revealAdjacentCells(currentCell.gridY, currentCell.gridX);
        }
        updateMinesweeperGridUI();
        checkWinCondition();
      }

      // ã‚»ãƒ«é–‹å°
      function revealCell(cell) {
        if (cell.isRevealed || cell.isFlagged) return;
        cell.isRevealed = true;
        cellsRevealed++;

        if (cell.isMine) {
          cell.setStyle({ fillOpacity: 0.5, fillColor: "#ff0000" });
        } else {
          if (cell.adjacentMines === 0) {
            cell.setStyle({
              fillOpacity: 0.5,
              fillColor: "rgba(255,255,255,0.5)",
            });
          } else {
            const colors = [
              "rgba(255,255,255,0.5)",
              "#0000ff",
              "#008000",
              "#ff0000",
              "#000080",
              "#800000",
              "#008080",
              "#000000",
              "#808080",
            ];
            cell.setStyle({
              fillOpacity: 0.5,
              fillColor: colors[cell.adjacentMines],
            });
          }
        }
      }

      // å‘¨å›²ã‚’å†å¸°çš„ã«é–‹ã
      function revealAdjacentCells(row, col) {
        for (let dy = -1; dy <= 1; dy++) {
          for (let dx = -1; dx <= 1; dx++) {
            if (dy === 0 && dx === 0) continue;
            const ny = row + dy,
              nx = col + dx;
            if (ny < 0 || ny >= GRID_SIZE || nx < 0 || nx >= GRID_SIZE)
              continue;
            const idx = ny * GRID_SIZE + nx;
            const nCell = gridPolygons[idx];
            if (!nCell.isRevealed && !nCell.isFlagged) {
              revealCell(nCell);
              if (!nCell.isMine && nCell.adjacentMines === 0) {
                revealAdjacentCells(ny, nx);
              }
            }
          }
        }
      }

      // åœ°é›·é…ç½®
      function initializeMinesweeperGame(firstX, firstY) {
        mineCount = Math.floor(GRID_SIZE * GRID_SIZE * 0.15);
        if (mineCount < 10) mineCount = 10;
        if (mineCount > 100) mineCount = 100;

        flagsUsed = 0;
        gameOver = false;
        gameWon = false;
        cellsRevealed = 0;
        mines = [];

        let minesPlaced = 0;
        const safeZone = [];
        for (let dy = -1; dy <= 1; dy++) {
          for (let dx = -1; dx <= 1; dx++) {
            safeZone.push({ x: firstX + dx, y: firstY + dy });
          }
        }

        while (minesPlaced < mineCount) {
          const rx = Math.floor(Math.random() * GRID_SIZE);
          const ry = Math.floor(Math.random() * GRID_SIZE);
          if (safeZone.some((pos) => pos.x === rx && pos.y === ry)) continue;
          const idx = ry * GRID_SIZE + rx;
          if (!gridPolygons[idx].isMine) {
            gridPolygons[idx].isMine = true;
            mines.push({ x: rx, y: ry });
            minesPlaced++;
          }
        }

        // éš£æ¥åœ°é›·æ•°è¨ˆç®—
        for (let r = 0; r < GRID_SIZE; r++) {
          for (let c = 0; c < GRID_SIZE; c++) {
            const idx = r * GRID_SIZE + c;
            if (gridPolygons[idx].isMine) continue;
            let count = 0;
            for (let dy = -1; dy <= 1; dy++) {
              for (let dx = -1; dx <= 1; dx++) {
                if (dy === 0 && dx === 0) continue;
                const nr = r + dy,
                  nc = c + dx;
                if (nr < 0 || nr >= GRID_SIZE || nc < 0 || nc >= GRID_SIZE)
                  continue;
                const nIdx = nr * GRID_SIZE + nc;
                if (gridPolygons[nIdx].isMine) count++;
              }
            }
            gridPolygons[idx].adjacentMines = count;
          }
        }
      }

      // å…¨åœ°é›·ã‚’è¡¨ç¤º
      function revealAllMines() {
        mines.forEach((m) => {
          const idx = m.y * GRID_SIZE + m.x;
          const mineCell = gridPolygons[idx];
          if (!mineCell.isFlagged) {
            mineCell.setStyle({ fillOpacity: 0.5, fillColor: "#ff0000" });
          }
        });
      }

      // å‹åˆ©æ¡ä»¶
      function checkWinCondition() {
        const totalCells = GRID_SIZE * GRID_SIZE;
        const nonMineCells = totalCells - mineCount;

        let correctFlags = 0;
        mines.forEach((m) => {
          const idx = m.y * GRID_SIZE + m.x;
          if (gridPolygons[idx].isFlagged) {
            correctFlags++;
          }
        });

        if (cellsRevealed === nonMineCells || correctFlags === mineCount) {
          gameWon = true;
          gameOver = true;
          // å…¨åœ°é›·ã«æ——ä»˜ã‘
          mines.forEach((m) => {
            const idx = m.y * GRID_SIZE + m.x;
            if (!gridPolygons[idx].isFlagged) {
              gridPolygons[idx].isFlagged = true;
              flagsUsed++;
            }
          });
          updateMinesweeperGridUI();
          document.getElementById("resetButton").style.display = "block";
        }
      }

      // ãƒªã‚»ãƒƒãƒˆ
      function resetGame() {
        gameOver = false;
        gameWon = false;
        minesInitialized = false;
        cellsRevealed = 0;
        mineCount = 0;
        flagsUsed = 0;
        mines = [];

        gridPolygons.forEach((p) => {
          p.isMine = false;
          p.isFlagged = false;
          p.isRevealed = false;
          p.adjacentMines = 0;
          p.setStyle({
            color: "black",
            weight: 1,
            fillOpacity: 0.1,
            fillColor: "gray",
          });
        });

        document.getElementById("resetButton").style.display = "none";
        updateMinesweeperGridUI();
      }
    </script>
  </body>
</html>
