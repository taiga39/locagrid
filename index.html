<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>ä½ç½®æ¸¬å®šãƒã‚¤ãƒ³ã‚¹ã‚¤ãƒ¼ãƒ‘ãƒ¼</title>
  <!-- Leafletã®CSS -->
  <link rel="stylesheet" href="https://unpkg.com/leaflet/dist/leaflet.css" />
  <style>
    body { margin: 0; padding: 0; }
    #map { height: 400px; }
    .controls { margin: 10px; }
    .accuracy, .position { margin: 10px; }
    .game-controls { 
      margin: 10px; 
      display: none;
    }
    .game-info {
      margin: 10px 0;
      display: none;
    }
    
    /* ãƒã‚¤ãƒ³ã‚¹ã‚¤ãƒ¼ãƒ‘ãƒ¼ã‚°ãƒªãƒƒãƒ‰è¡¨ç¤ºç”¨ */
    #minesweeperGrid {
      display: none;
      margin: 10px auto;
    }
    .grid-row {
      display: flex;
    }
    .grid-cell {
      width: 30px;
      height: 30px;
      border: 1px solid #999;
      display: flex;
      align-items: center;
      justify-content: center;
      font-weight: bold;
      background-color: #ddd;
    }
    .revealed {
      background-color: #eee;
    }
    .mine {
      background-color: #f88;
    }
    .flagged {
      background-color: #faa;
    }
    .current-position {
      border: 2px solid blue;
    }
    .number-1 { color: blue; }
    .number-2 { color: green; }
    .number-3 { color: red; }
    .number-4 { color: darkblue; }
    .number-5 { color: darkred; }
    .number-6 { color: darkcyan; }
    .number-7 { color: black; }
    .number-8 { color: gray; }
  </style>
</head>
<body>
  <div class="controls">
    <label for="cellSizeSelect">ã‚»ãƒ«ã‚µã‚¤ã‚º (m):</label>
    <select id="cellSizeSelect">
      <option value="30">30</option>
      <option value="60">60</option>
      <option value="100" selected>100</option>
      <option value="500">500</option>
      <option value="1000">1000</option>
    </select>

    <label for="gridSizeSelect">ã‚°ãƒªãƒƒãƒ‰ã‚µã‚¤ã‚º:</label>
    <select id="gridSizeSelect">
      <option value="9" selected>9Ã—9</option>
      <option value="17">17Ã—17</option>
      <option value="31">31Ã—31</option>
    </select>

    <button id="getLocationButton" onclick="getLocation()">å ´æ‰€ã‚’å–å¾—</button>
    <button id="startGridButton" onclick="startGrid()" disabled>ã‚°ãƒªãƒƒãƒ‰é–‹å§‹</button>
  </div>

  <div class="accuracy"></div>
  <div id="map"></div>
  <div class="position"></div>
  
  <!-- ã‚²ãƒ¼ãƒ æ“ä½œç”¨ãƒœã‚¿ãƒ³ -->
  <div class="game-controls" id="gameControls">
    <button id="flagButton" onclick="actionFlag()">æ——ã‚’ç«‹ã¦ã‚‹</button>
    <button id="openButton" onclick="actionOpen()">é–‹ã</button>
  </div>

  <div class="game-info" id="gameInfo">
    <span id="minesLeft"></span> | 
    <span id="gameStatus"></span>
  </div>
  
  <!-- ä¸‹éƒ¨ãƒã‚¤ãƒ³ã‚¹ã‚¤ãƒ¼ãƒ‘ãƒ¼ã‚°ãƒªãƒƒãƒ‰è¡¨ç¤º -->
  <div id="minesweeperGrid"></div>

  <!-- Leafletã®JS -->
  <script src="https://unpkg.com/leaflet/dist/leaflet.js"></script>
  <script>
    // ã‚°ãƒ­ãƒ¼ãƒãƒ«å¤‰æ•°
    let basePosition = null;
    let map;
    let gridOverlayGroup = L.layerGroup();
    let CELL_SIZE, GRID_SIZE;
    const gridPolygons = [];
    let topLeftLat, topLeftLng, latDiff, lngDiff;
    let watchId = null;
    let gridFixed = false;
    let currentCell = null;
    
    // ãƒã‚¤ãƒ³ã‚¹ã‚¤ãƒ¼ãƒ‘ãƒ¼ç”¨å¤‰æ•°
    let mines = [];
    let mineCount = 0;
    let flagsUsed = 0;
    let gameOver = false;
    let gameWon = false;
    let cellsRevealed = 0;

    // ãƒšãƒ¼ã‚¸èª­ã¿è¾¼ã¿æ™‚ã«åœ°å›³ã‚’åˆæœŸè¡¨ç¤º
    window.addEventListener("DOMContentLoaded", function() {
      map = L.map('map').setView([35.6895, 139.6917], 10);
      L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
        attribution: 'Â© OpenStreetMap contributors'
      }).addTo(map);
      gridOverlayGroup.addTo(map);

      // select boxã®å¤‰æ›´ã‚¤ãƒ™ãƒ³ãƒˆ
      document.getElementById('cellSizeSelect').addEventListener('change', updateTentativeGrid);
      document.getElementById('gridSizeSelect').addEventListener('change', updateTentativeGrid);
    });

    // ã€Œå ´æ‰€ã‚’å–å¾—ã€ãƒœã‚¿ãƒ³æŠ¼ä¸‹æ™‚
    function getLocation() {
      const getLocationButton = document.getElementById('getLocationButton');
      getLocationButton.textContent = "ä½ç½®æƒ…å ±å–å¾—ä¸­...";
      getLocationButton.disabled = true;

      if ("geolocation" in navigator) {
        navigator.geolocation.getCurrentPosition(pos => {
          basePosition = {
            lat: pos.coords.latitude,
            lng: pos.coords.longitude
          };
          // åœ°å›³ã®ä¸­å¿ƒã‚’æ›´æ–°ï¼ˆã‚ºãƒ¼ãƒ ãƒ¬ãƒ™ãƒ«19ï¼‰
          map.setView([basePosition.lat, basePosition.lng], 19);

          getLocationButton.textContent = "å ´æ‰€å–å¾—æ¸ˆã¿";
          document.getElementById('startGridButton').disabled = false;
          
          // æš«å®šã‚°ãƒªãƒƒãƒ‰è¡¨ç¤º
          updateTentativeGrid();
          
          // ä½ç½®ç›£è¦–é–‹å§‹
          if (watchId === null) {
            watchId = navigator.geolocation.watchPosition(updatePosition, null, {
              enableHighAccuracy: true,
              timeout: 5000,
              maximumAge: 0
            });
          }
        }, err => {
          getLocationButton.textContent = "å–å¾—å¤±æ•—";
          console.error(err);
        });
      }
    }

    // æš«å®šã‚°ãƒªãƒƒãƒ‰æ›´æ–°
    function updateTentativeGrid() {
      if (!basePosition || gridFixed) return;
      
      CELL_SIZE = parseInt(document.getElementById('cellSizeSelect').value, 10);
      GRID_SIZE = parseInt(document.getElementById('gridSizeSelect').value, 10);
      
      const metersPerDegree = 111320;
      latDiff = CELL_SIZE / metersPerDegree;
      lngDiff = CELL_SIZE / (metersPerDegree * Math.cos(basePosition.lat * Math.PI / 180));

      const centerIndex = (GRID_SIZE - 1) / 2;
      topLeftLat = basePosition.lat + (centerIndex + 0.5) * latDiff;
      topLeftLng = basePosition.lng - (centerIndex + 0.5) * lngDiff;

      drawGridOverlay();
    }

    // ã€Œã‚°ãƒªãƒƒãƒ‰é–‹å§‹ã€ãƒœã‚¿ãƒ³æŠ¼ä¸‹æ™‚ï¼ˆãƒã‚¤ãƒ³ã‚¹ã‚¤ãƒ¼ãƒ‘ãƒ¼é–‹å§‹ï¼‰
    function startGrid() {
      gridFixed = true;
      document.getElementById('cellSizeSelect').disabled = true;
      document.getElementById('gridSizeSelect').disabled = true;
      document.getElementById('startGridButton').disabled = true;
      
      // ãƒã‚¤ãƒ³ã‚¹ã‚¤ãƒ¼ãƒ‘ãƒ¼ã®ã‚²ãƒ¼ãƒ åˆæœŸåŒ–
      initializeMinesweeperGame();
      
      // ã‚²ãƒ¼ãƒ ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ«ã‚’è¡¨ç¤º
      document.getElementById('gameControls').style.display = 'block';
      document.getElementById('gameInfo').style.display = 'block';
      document.getElementById('minesweeperGrid').style.display = 'block';
      
      // ä¸‹éƒ¨ã®ãƒã‚¤ãƒ³ã‚¹ã‚¤ãƒ¼ãƒ‘ãƒ¼ã‚°ãƒªãƒƒãƒ‰ã‚’ä½œæˆ
      createMinesweeperGridUI();
    }

    // ã‚°ãƒªãƒƒãƒ‰æç”»
    function drawGridOverlay() {
      gridOverlayGroup.clearLayers();
      gridPolygons.length = 0;

      for (let i = 0; i < GRID_SIZE; i++) {
        for (let j = 0; j < GRID_SIZE; j++) {
          const bounds = [
            [topLeftLat - i * latDiff,       topLeftLng + j * lngDiff],
            [topLeftLat - i * latDiff,       topLeftLng + (j + 1) * lngDiff],
            [topLeftLat - (i + 1) * latDiff, topLeftLng + (j + 1) * lngDiff],
            [topLeftLat - (i + 1) * latDiff, topLeftLng + j * lngDiff]
          ];
          const polygon = L.polygon(bounds, {
            color: 'black',
            weight: 1,
            fillOpacity: 0.1,
            fillColor: 'gray'
          });
          polygon.gridX = j;
          polygon.gridY = i;
          // ãƒã‚¤ãƒ³ã‚¹ã‚¤ãƒ¼ãƒ‘ãƒ¼ç”¨ã®çŠ¶æ…‹
          polygon.isRevealed = false;
          polygon.isFlagged = false;
          polygon.isMine = false;
          polygon.adjacentMines = 0;
          polygon.addTo(gridOverlayGroup);
          gridPolygons.push(polygon);
        }
      }
    }

    // ä½ç½®æ›´æ–°æ™‚
    function updatePosition(pos) {
      const accuracy = pos.coords.accuracy;
      const accuracyDiv = document.querySelector('.accuracy');
      let accuracyText = 'è¦æ³¨æ„';
      if (accuracy <= 10) {
        accuracyText = 'ã¨ã¦ã‚‚è‰¯å¥½';
      } else if (accuracy <= 20) {
        accuracyText = 'æ™®é€š';
      }
      accuracyDiv.textContent = `ç²¾åº¦: ${Math.round(accuracy)}m (${accuracyText})`;

      // ç¾åœ¨ä½ç½®ã¨ã‚°ãƒªãƒƒãƒ‰å·¦ä¸Šã¨ã®å·®ã‚’è¨ˆç®—
      const deltaLat = topLeftLat - pos.coords.latitude;
      const deltaLng = pos.coords.longitude - topLeftLng;
      const gridY = Math.floor(deltaLat / latDiff);
      const gridX = Math.floor(deltaLng / lngDiff);

      // ç¾åœ¨ä½ç½®è¡¨ç¤º
      const positionDiv = document.querySelector('.position');
      if (gridX >= 0 && gridX < GRID_SIZE && gridY >= 0 && gridY < GRID_SIZE) {
        positionDiv.textContent = `ç¾åœ¨ä½ç½®: ã‚°ãƒªãƒƒãƒ‰(${gridX + 1}, ${gridY + 1})`;
      } else {
        positionDiv.textContent = `ç¾åœ¨ä½ç½®: ã‚°ãƒªãƒƒãƒ‰å¤–`;
      }

      // ã‚°ãƒªãƒƒãƒ‰å†…ã§ã®ãƒã‚¤ãƒ©ã‚¤ãƒˆæ›´æ–°
      // æ—¢ã«çŠ¶æ…‹ãŒå¤‰ã‚ã£ãŸã‚»ãƒ«ï¼ˆé–‹ã‹ã‚ŒãŸoræ——ãŒç«‹ã£ã¦ã„ã‚‹ï¼‰ã¯ãã®ã¾ã¾è¡¨ç¤º
      gridPolygons.forEach(polygon => {
        if (!polygon.isRevealed && !polygon.isFlagged) {
          polygon.setStyle({
            fillOpacity: 0.1,
            fillColor: 'gray'
          });
        }
      });

      // ç¾åœ¨ä½ç½®ã®ã‚»ãƒ«ã‚’å–å¾—ã—ã¦ãƒã‚¤ãƒ©ã‚¤ãƒˆ
      let oldCell = currentCell;
      currentCell = null;
      if (gridX >= 0 && gridX < GRID_SIZE && gridY >= 0 && gridY < GRID_SIZE) {
        gridPolygons.forEach(polygon => {
          if (polygon.gridX === gridX && polygon.gridY === gridY) {
            currentCell = polygon;
            
            // ã‚²ãƒ¼ãƒ é–‹å§‹å¾Œã‹ã¤ã‚²ãƒ¼ãƒ ã‚ªãƒ¼ãƒãƒ¼ã§ãªã‘ã‚Œã°ã€ç¾åœ¨ã®ã‚»ãƒ«ã‚’ãƒã‚¤ãƒ©ã‚¤ãƒˆ
            if (gridFixed && !gameOver && !polygon.isRevealed && !polygon.isFlagged) {
              polygon.setStyle({
                fillOpacity: 0.5,
                fillColor: 'blue'
              });
            }
          }
        });
      }
      
      // ç¾åœ¨ä½ç½®ãŒå¤‰ã‚ã£ãŸã‚‰ä¸‹éƒ¨ã®ãƒã‚¤ãƒ³ã‚¹ã‚¤ãƒ¼ãƒ‘ãƒ¼ã‚°ãƒªãƒƒãƒ‰è¡¨ç¤ºã‚‚æ›´æ–°
      if (gridFixed && (oldCell !== currentCell)) {
        updateMinesweeperGridUI();
      }

      // ãƒãƒ¼ã‚«ãƒ¼ï¼ˆãƒ”ãƒ³ï¼‰ã®æ›´æ–°
      if (currentCell) {
        const cellCenterLat = topLeftLat - (gridY + 0.5) * latDiff;
        const cellCenterLng = topLeftLng + (gridX + 0.5) * lngDiff;
        
        if (!updatePosition.marker) {
          updatePosition.marker = L.marker([cellCenterLat, cellCenterLng]).addTo(map);
        } else {
          updatePosition.marker.setLatLng([cellCenterLat, cellCenterLng]);
        }
      } else if (!updatePosition.marker && !gridFixed) {
        // ã‚°ãƒªãƒƒãƒ‰ç¢ºå®šå‰ã¯ã€ç¾åœ¨ä½ç½®ã«ãƒãƒ¼ã‚«ãƒ¼ã‚’è¡¨ç¤º
        updatePosition.marker = L.marker([pos.coords.latitude, pos.coords.longitude]).addTo(map);
      } else if (updatePosition.marker && !gridFixed) {
        // ã‚°ãƒªãƒƒãƒ‰ç¢ºå®šå‰ã®ãƒãƒ¼ã‚«ãƒ¼ä½ç½®æ›´æ–°
        updatePosition.marker.setLatLng([pos.coords.latitude, pos.coords.longitude]);
      }
    }

    // ãƒã‚¤ãƒ³ã‚¹ã‚¤ãƒ¼ãƒ‘ãƒ¼ã‚²ãƒ¼ãƒ åˆæœŸåŒ–
    function initializeMinesweeperGame() {
      // ã‚²ãƒ¼ãƒ å¤‰æ•°ã®åˆæœŸåŒ–
      mineCount = Math.floor(GRID_SIZE * GRID_SIZE * 0.15); // ã‚°ãƒªãƒƒãƒ‰ã®ç´„15%ã‚’åœ°é›·ã«
      if (mineCount < 10) mineCount = 10; // æœ€ä½10å€‹ã®åœ°é›·
      if (mineCount > 100) mineCount = 100; // æœ€å¤§100å€‹ã®åœ°é›·
      
      flagsUsed = 0;
      gameOver = false;
      gameWon = false;
      cellsRevealed = 0;
      mines = [];
      
      document.getElementById('minesLeft').textContent = `æ®‹ã‚Šåœ°é›·: ${mineCount - flagsUsed}`;
      document.getElementById('gameStatus').textContent = `ã‚²ãƒ¼ãƒ é–‹å§‹ï¼`;
      
      // åœ°é›·ã®é…ç½®
      let minesPlaced = 0;
      while (minesPlaced < mineCount) {
        const x = Math.floor(Math.random() * GRID_SIZE);
        const y = Math.floor(Math.random() * GRID_SIZE);
        
        // gridPolygonsã‹ã‚‰è©²å½“ã‚»ãƒ«ã‚’æ¤œç´¢
        const cellIndex = y * GRID_SIZE + x;
        if (cellIndex >= 0 && cellIndex < gridPolygons.length && !gridPolygons[cellIndex].isMine) {
          gridPolygons[cellIndex].isMine = true;
          mines.push({ x, y });
          minesPlaced++;
        }
      }
      
      // éš£æ¥ã™ã‚‹åœ°é›·æ•°ã®è¨ˆç®—
      for (let y = 0; y < GRID_SIZE; y++) {
        for (let x = 0; x < GRID_SIZE; x++) {
          const cellIndex = y * GRID_SIZE + x;
          if (gridPolygons[cellIndex].isMine) continue;
          
          let count = 0;
          // 8æ–¹å‘ã‚’ãƒã‚§ãƒƒã‚¯
          for (let dy = -1; dy <= 1; dy++) {
            for (let dx = -1; dx <= 1; dx++) {
              if (dx === 0 && dy === 0) continue;
              
              const nx = x + dx;
              const ny = y + dy;
              
              if (nx >= 0 && nx < GRID_SIZE && ny >= 0 && ny < GRID_SIZE) {
                const neighborIndex = ny * GRID_SIZE + nx;
                if (gridPolygons[neighborIndex].isMine) {
                  count++;
                }
              }
            }
          }
          gridPolygons[cellIndex].adjacentMines = count;
        }
      }
    }

    // ãƒã‚¤ãƒ³ã‚¹ã‚¤ãƒ¼ãƒ‘ãƒ¼æ“ä½œï¼šæ——ã‚’ç«‹ã¦ã‚‹
    function actionFlag() {
      if (!gridFixed || !currentCell || gameOver || currentCell.isRevealed) return;
      
      // æ——ã®åˆ‡ã‚Šæ›¿ãˆ
      currentCell.isFlagged = !currentCell.isFlagged;
      
      if (currentCell.isFlagged) {
        currentCell.setStyle({
          fillOpacity: 0.7,
          fillColor: 'red'
        });
        flagsUsed++;
      } else {
        currentCell.setStyle({
          fillOpacity: 0.5,
          fillColor: 'blue'
        });
        flagsUsed--;
      }
      
      // æ®‹ã‚Šã®åœ°é›·æ•°è¡¨ç¤ºã‚’æ›´æ–°
      document.getElementById('minesLeft').textContent = `æ®‹ã‚Šåœ°é›·: ${mineCount - flagsUsed}`;
      
      // ä¸‹éƒ¨ã®ãƒã‚¤ãƒ³ã‚¹ã‚¤ãƒ¼ãƒ‘ãƒ¼ã‚°ãƒªãƒƒãƒ‰è¡¨ç¤ºã‚’æ›´æ–°
      updateMinesweeperGridUI();
      
      // å‹åˆ©æ¡ä»¶ãƒã‚§ãƒƒã‚¯ï¼šã™ã¹ã¦ã®åœ°é›·ã«æ­£ã—ãæ——ãŒç«‹ã£ã¦ã„ã‚‹ã‹
      checkWinCondition();
    }

    // ãƒã‚¤ãƒ³ã‚¹ã‚¤ãƒ¼ãƒ‘ãƒ¼æ“ä½œï¼šã‚»ãƒ«ã‚’é–‹ã
    function actionOpen() {
      if (!gridFixed || !currentCell || gameOver || currentCell.isRevealed || currentCell.isFlagged) return;
      
      // ã‚»ãƒ«ã‚’é–‹ã
      revealCell(currentCell);
      
      // åœ°é›·ã‚’è¸ã‚“ã å ´åˆ
      if (currentCell.isMine) {
        gameOver = true;
        revealAllMines();
        document.getElementById('gameStatus').textContent = 'ã‚²ãƒ¼ãƒ ã‚ªãƒ¼ãƒãƒ¼ï¼åœ°é›·ã‚’è¸ã¿ã¾ã—ãŸ';
        updateMinesweeperGridUI();
        return;
      }
      
      // ç©ºã®ã‚»ãƒ«ï¼ˆéš£æ¥åœ°é›·ãªã—ï¼‰ã®å ´åˆã¯å‘¨å›²ã‚’å†å¸°çš„ã«é–‹ã
      if (currentCell.adjacentMines === 0) {
        revealAdjacentCells(currentCell.gridY, currentCell.gridX);
      }
      
      // ä¸‹éƒ¨ã®ãƒã‚¤ãƒ³ã‚¹ã‚¤ãƒ¼ãƒ‘ãƒ¼ã‚°ãƒªãƒƒãƒ‰è¡¨ç¤ºã‚’æ›´æ–°
      updateMinesweeperGridUI();
      
      // å‹åˆ©æ¡ä»¶ãƒã‚§ãƒƒã‚¯
      checkWinCondition();
    }
    
    // ã‚»ãƒ«ã‚’é–‹ãå‡¦ç†
    function revealCell(cell) {
      if (cell.isRevealed || cell.isFlagged) return;
      
      cell.isRevealed = true;
      cellsRevealed++;
      
      // ã‚»ãƒ«ã®ã‚¹ã‚¿ã‚¤ãƒ«æ›´æ–°
      if (cell.isMine) {
        cell.setStyle({
          fillOpacity: 0.8,
          fillColor: '#ff0000'  // åœ°é›·ã¯èµ¤
        });
      } else {
        let color;
        if (cell.adjacentMines === 0) {
          color = '#ffffff';  // ç©ºã‚»ãƒ«ã¯ç™½
        } else {
          // æ•°å­—ã«å¿œã˜ãŸè‰²
          const colors = ['#ffffff', '#0000ff', '#008000', '#ff0000', '#000080', '#800000', '#008080', '#000000', '#808080'];
          color = colors[cell.adjacentMines];
        }
        
        cell.setStyle({
          fillOpacity: 0.8,
          fillColor: color
        });
        
        // æ•°å­—ã‚’è¡¨ç¤ºï¼ˆé©åˆ‡ãªæ–¹æ³•ã§æç”»ã€ã“ã®ä¾‹ã§ã¯ãƒãƒƒãƒ—ã‚¢ãƒƒãƒ—ã§ï¼‰
        if (cell.adjacentMines > 0) {
          if (cell._popup) {
            cell.unbindPopup();
          }
          cell.bindPopup(cell.adjacentMines.toString(), {
            closeButton: false,
            autoClose: false,
            className: 'mine-number'
          }).openPopup();
        }
      }
    }
    
    // å‘¨å›²ã®ã‚»ãƒ«ã‚’å†å¸°çš„ã«é–‹ã
    function revealAdjacentCells(y, x) {
      for (let dy = -1; dy <= 1; dy++) {
        for (let dx = -1; dx <= 1; dx++) {
          if (dx === 0 && dy === 0) continue;
          
          const nx = x + dx;
          const ny = y + dy;
          
          if (nx >= 0 && nx < GRID_SIZE && ny >= 0 && ny < GRID_SIZE) {
            const neighborIndex = ny * GRID_SIZE + nx;
            const neighborCell = gridPolygons[neighborIndex];
            
            if (!neighborCell.isRevealed && !neighborCell.isFlagged) {
              revealCell(neighborCell);
              
              // ç©ºã‚»ãƒ«ãªã‚‰å†å¸°çš„ã«å‘¨å›²ã‚‚é–‹ã
              if (neighborCell.adjacentMines === 0) {
                revealAdjacentCells(ny, nx);
              }
            }
          }
        }
      }
    }
    
    // ã™ã¹ã¦ã®åœ°é›·ã‚’è¡¨ç¤º
    function revealAllMines() {
      for (const mine of mines) {
        const index = mine.y * GRID_SIZE + mine.x;
        const mineCell = gridPolygons[index];
        if (!mineCell.isFlagged) {
          mineCell.setStyle({
            fillOpacity: 0.8,
            fillColor: '#ff0000'  // åœ°é›·ã¯èµ¤
          });
        }
      }
    }
    
    // å‹åˆ©æ¡ä»¶ãƒã‚§ãƒƒã‚¯
    function checkWinCondition() {
      // å‹åˆ©æ¡ä»¶1: ã™ã¹ã¦ã®éåœ°é›·ã‚»ãƒ«ãŒé–‹ã‹ã‚Œã¦ã„ã‚‹
      const nonMineTotal = GRID_SIZE * GRID_SIZE - mineCount;
      
      // å‹åˆ©æ¡ä»¶2: ã™ã¹ã¦ã®åœ°é›·ã«æ­£ã—ãæ——ãŒç«‹ã£ã¦ã„ã‚‹
      let correctFlags = 0;
      for (const mine of mines) {
        const index = mine.y * GRID_SIZE + mine.x;
        if (gridPolygons[index].isFlagged) {
          correctFlags++;
        }
      }
      
      if (cellsRevealed === nonMineTotal || correctFlags === mineCount) {
        gameWon = true;
        gameOver = true;
        document.getElementById('gameStatus').textContent = 'ã‚²ãƒ¼ãƒ ã‚¯ãƒªã‚¢ï¼ãŠã‚ã§ã¨ã†ã”ã–ã„ã¾ã™ï¼';
        
        // å…¨ã¦ã®åœ°é›·ã«æ——ã‚’ç«‹ã¦ã‚‹
        for (const mine of mines) {
          const index = mine.y * GRID_SIZE + mine.x;
          if (!gridPolygons[index].isFlagged) {
            gridPolygons[index].isFlagged = true;
            flagsUsed++;
          }
        }
        
        // ä¸‹éƒ¨ã®ãƒã‚¤ãƒ³ã‚¹ã‚¤ãƒ¼ãƒ‘ãƒ¼ã‚°ãƒªãƒƒãƒ‰è¡¨ç¤ºã‚’æ›´æ–°
        updateMinesweeperGridUI();
      }
    }
    
    // ä¸‹éƒ¨ãƒã‚¤ãƒ³ã‚¹ã‚¤ãƒ¼ãƒ‘ãƒ¼ã‚°ãƒªãƒƒãƒ‰UIã®ä½œæˆ
    function createMinesweeperGridUI() {
      const container = document.getElementById('minesweeperGrid');
      container.innerHTML = '';
      
      for (let y = 0; y < GRID_SIZE; y++) {
        const rowDiv = document.createElement('div');
        rowDiv.className = 'grid-row';
        
        for (let x = 0; x < GRID_SIZE; x++) {
          const cell = document.createElement('div');
          cell.className = 'grid-cell';
          cell.dataset.x = x;
          cell.dataset.y = y;
          rowDiv.appendChild(cell);
        }
        
        container.appendChild(rowDiv);
      }
      
      // åˆæœŸçŠ¶æ…‹ã‚’åæ˜ 
      updateMinesweeperGridUI();
    }
    
    // ä¸‹éƒ¨ãƒã‚¤ãƒ³ã‚¹ã‚¤ãƒ¼ãƒ‘ãƒ¼ã‚°ãƒªãƒƒãƒ‰UIã®æ›´æ–°
    function updateMinesweeperGridUI() {
      if (!gridFixed) return;
      
      const cells = document.querySelectorAll('.grid-cell');
      cells.forEach(cell => {
        const x = parseInt(cell.dataset.x);
        const y = parseInt(cell.dataset.y);
        const index = y * GRID_SIZE + x;
        const polygon = gridPolygons[index];
        
        // ã‚»ãƒ«ã®ã‚¯ãƒ©ã‚¹ã‚’ãƒªã‚»ãƒƒãƒˆ
        cell.className = 'grid-cell';
        cell.textContent = '';
        
        // ç¾åœ¨ä½ç½®ã‚’ãƒã‚¤ãƒ©ã‚¤ãƒˆ
        if (currentCell && currentCell.gridX === x && currentCell.gridY === y) {
          cell.classList.add('current-position');
        }
        
        if (polygon.isRevealed) {
          cell.classList.add('revealed');
          
          if (polygon.isMine) {
            cell.classList.add('mine');
            cell.textContent = 'ğŸ’£';
          } else if (polygon.adjacentMines > 0) {
            cell.textContent = polygon.adjacentMines;
            cell.classList.add(`number-${polygon.adjacentMines}`);
          }
        } else if (polygon.isFlagged) {
          cell.classList.add('flagged');
          cell.textContent = 'ğŸš©';
        }
      });
    }
  </script>
</body>
</html>