<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>ä½ç½®æ¸¬å®šãƒã‚¤ãƒ³ã‚¹ã‚¤ãƒ¼ãƒ‘ãƒ¼</title>
  <!-- Leafletã®CSS -->
  <link rel="stylesheet" href="https://unpkg.com/leaflet/dist/leaflet.css" />
  <style>
    body { margin: 0; padding: 0; }
    #map { height: 300px; }
    .controls { margin: 10px; }
    .accuracy, .position { margin: 10px; }
    
    /* ãƒã‚¤ãƒ³ã‚¹ã‚¤ãƒ¼ãƒ‘ãƒ¼ç”¨ã‚¹ã‚¿ã‚¤ãƒ« */
    #minesweeperContainer {
      display: none;
      margin: 10px;
    }
    .cell {
      width: 30px;
      height: 30px;
      border: 1px solid #999;
      display: flex;
      align-items: center;
      justify-content: center;
      font-weight: bold;
      background-color: #ddd;
      cursor: pointer;
    }
    .revealed {
      background-color: #eee;
    }
    .mine {
      background-color: #f88;
    }
    .grid {
      display: grid;
      grid-gap: 1px;
      background-color: #999;
      padding: 1px;
      margin-top: 10px;
    }
    .game-info {
      margin: 10px 0;
    }
    .number-1 { color: blue; }
    .number-2 { color: green; }
    .number-3 { color: red; }
    .number-4 { color: darkblue; }
    .number-5 { color: darkred; }
    .number-6 { color: darkcyan; }
    .number-7 { color: black; }
    .number-8 { color: gray; }
  </style>
</head>
<body>
  <div class="controls">
    <label for="cellSizeSelect">ã‚»ãƒ«ã‚µã‚¤ã‚º (m):</label>
    <select id="cellSizeSelect">
      <option value="30">30</option>
      <option value="60">60</option>
      <option value="100">100</option>
      <option value="500">500</option>
      <option value="1000">1000</option>
    </select>

    <label for="gridSizeSelect">ã‚°ãƒªãƒƒãƒ‰ã‚µã‚¤ã‚º:</label>
    <select id="gridSizeSelect">
      <option value="9">9Ã—9</option>
      <option value="17">17Ã—17</option>
      <option value="31">31Ã—31</option>
    </select>

    <button id="startButton" onclick="startTracking()">ä½ç½®æ¸¬å®šã‚’é–‹å§‹</button>
  </div>

  <div class="accuracy"></div>
  <div id="map"></div>
  <div class="position"></div>
  
  <!-- ãƒã‚¤ãƒ³ã‚¹ã‚¤ãƒ¼ãƒ‘ãƒ¼ã‚³ãƒ³ãƒ†ãƒŠ -->
  <div id="minesweeperContainer">
    <h3>ä½ç½®æ¸¬å®šãƒã‚¤ãƒ³ã‚¹ã‚¤ãƒ¼ãƒ‘ãƒ¼</h3>
    <div class="game-info">
      <span id="flagsLeft"></span> | 
      <button id="resetGame">ãƒªã‚»ãƒƒãƒˆ</button>
    </div>
    <div id="minesweeperGrid" class="grid"></div>
  </div>

  <!-- Leafletã®JS -->
  <script src="https://unpkg.com/leaflet/dist/leaflet.js"></script>
  <script>
    let basePosition = null;
    let map;
    let gridOverlayGroup = L.layerGroup(); // åœ°å›³ä¸Šã®ã‚°ãƒªãƒƒãƒ‰ç”¨ãƒ¬ã‚¤ãƒ¤ãƒ¼ã‚°ãƒ«ãƒ¼ãƒ—
    let CELL_SIZE, GRID_SIZE;  // ã‚»ãƒ«ã‚µã‚¤ã‚ºï¼ˆmï¼‰ã¨ã‚°ãƒªãƒƒãƒ‰ã‚µã‚¤ã‚ºï¼ˆã‚»ãƒ«æ•°ï¼‰
    const gridPolygons = [];   // å„ã‚»ãƒ«ã®ãƒãƒªã‚´ãƒ³ã‚’ä¿å­˜ã™ã‚‹é…åˆ—
    let topLeftLat, topLeftLng, latDiff, lngDiff; // ã‚°ãƒªãƒƒãƒ‰æç”»ç”¨ã®å…±é€šå¤‰æ•°
    
    // ãƒã‚¤ãƒ³ã‚¹ã‚¤ãƒ¼ãƒ‘ãƒ¼ç”¨å¤‰æ•°
    let mines = [];
    let gameBoard = [];
    let mineCount = 0;
    let flagsUsed = 0;
    let gameOver = false;
    let cellsRevealed = 0;
    let currentGridPosition = { x: -1, y: -1 };
    let lastGridPosition = { x: -1, y: -1 };

    function startTracking() {
      const startButton = document.getElementById('startButton');
      // ãƒœã‚¿ãƒ³ã®çŠ¶æ…‹å¤‰æ›´
      startButton.textContent = "ä½ç½®æƒ…å ±å–å¾—ä¸­...";
      startButton.disabled = true;

      // é¸æŠã•ã‚ŒãŸã‚»ãƒ«ã‚µã‚¤ã‚ºã¨ã‚°ãƒªãƒƒãƒ‰ã‚µã‚¤ã‚ºã‚’å–å¾—
      CELL_SIZE = parseInt(document.getElementById('cellSizeSelect').value, 10);
      GRID_SIZE = parseInt(document.getElementById('gridSizeSelect').value, 10);

      if ("geolocation" in navigator) {
        navigator.geolocation.getCurrentPosition(pos => {
          basePosition = {
            lat: pos.coords.latitude,
            lng: pos.coords.longitude
          };

          // 1ã‚»ãƒ«åˆ†ã®ç·¯åº¦çµŒåº¦å·®ã‚’è¨ˆç®—ï¼ˆæ¦‚ç®—ï¼‰
          const metersPerDegree = 111320;
          latDiff = CELL_SIZE / metersPerDegree;
          lngDiff = CELL_SIZE / (metersPerDegree * Math.cos(basePosition.lat * Math.PI / 180));
          
          // ã‚°ãƒªãƒƒãƒ‰ã®ä¸­å¿ƒã« basePosition ã‚’é…ç½®ã™ã‚‹ãŸã‚ã®å·¦ä¸Šã®åº§æ¨™è¨ˆç®—
          // ä¸­å¿ƒã‚»ãƒ«ã¯ ( (GRID_SIZE-1)/2, (GRID_SIZE-1)/2 ) ï¼ˆ0-indexedï¼‰
          const centerIndex = (GRID_SIZE - 1) / 2; 
          // basePositionã‚’ä¸­å¿ƒã«ã™ã‚‹ãŸã‚ã€å·¦ä¸Šã¯ basePositionã‹ã‚‰ (centerIndex + 0.5) ã‚»ãƒ«åˆ†ã‚ªãƒ•ã‚»ãƒƒãƒˆã™ã‚‹
          topLeftLat = basePosition.lat + (centerIndex + 0.5) * latDiff;
          topLeftLng = basePosition.lng - (centerIndex + 0.5) * lngDiff;

          // Leafletåœ°å›³ã®åˆæœŸåŒ–ï¼ˆã‚ºãƒ¼ãƒ ãƒ¬ãƒ™ãƒ«19ï¼‰
          map = L.map('map').setView([basePosition.lat, basePosition.lng], 19);
          L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
            attribution: 'Â© OpenStreetMap contributors'
          }).addTo(map);

          // é¸æŠã—ãŸã‚°ãƒªãƒƒãƒ‰ã‚µã‚¤ã‚ºã§ã‚ªãƒ¼ãƒãƒ¼ãƒ¬ã‚¤æç”»
          drawGridOverlay();
          
          // ãƒã‚¤ãƒ³ã‚¹ã‚¤ãƒ¼ãƒ‘ãƒ¼ã‚’åˆæœŸåŒ–
          initializeMinesweeper();
          document.getElementById('minesweeperContainer').style.display = 'block';

          // åˆæœŸä½ç½®å–å¾—å¾Œã€ãƒœã‚¿ãƒ³ã®è¡¨ç¤ºã‚’å¤‰æ›´
          startButton.textContent = "ä½ç½®æ¸¬å®šä¸­";
          
          // ä½ç½®ã®ç¶™ç¶šç›£è¦–ã‚’é–‹å§‹
          navigator.geolocation.watchPosition(updatePosition, null, {
            enableHighAccuracy: true,
            timeout: 5000,
            maximumAge: 0
          });
        }, err => {
          startButton.textContent = "å–å¾—å¤±æ•—";
          console.error(err);
        });
      }
    }

    // é¸æŠã•ã‚ŒãŸã‚°ãƒªãƒƒãƒ‰ã‚µã‚¤ã‚ºã§ã‚ªãƒ¼ãƒãƒ¼ãƒ¬ã‚¤æç”»
    function drawGridOverlay() {
      // æ—¢å­˜ã®ã‚°ãƒªãƒƒãƒ‰ã‚’ã‚¯ãƒªã‚¢
      gridOverlayGroup.clearLayers();
      gridPolygons.length = 0;

      // å·¦ä¸Šã®åº§æ¨™(topLeftLat, topLeftLng)ã‹ã‚‰GRID_SIZE x GRID_SIZEã®ã‚°ãƒªãƒƒãƒ‰ã‚’æç”»
      for (let i = 0; i < GRID_SIZE; i++) {
        for (let j = 0; j < GRID_SIZE; j++) {
          const bounds = [
            [topLeftLat - i * latDiff,       topLeftLng + j * lngDiff],
            [topLeftLat - i * latDiff,       topLeftLng + (j + 1) * lngDiff],
            [topLeftLat - (i + 1) * latDiff, topLeftLng + (j + 1) * lngDiff],
            [topLeftLat - (i + 1) * latDiff, topLeftLng + j * lngDiff]
          ];
          const polygon = L.polygon(bounds, {
            color: 'black',
            weight: 1,
            fillOpacity: 0.1,
            fillColor: 'gray'
          });
          // å„ã‚»ãƒ«ã®ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã‚’ä¿å­˜ï¼ˆ0-indexedï¼‰
          polygon.gridX = j;
          polygon.gridY = i;
          polygon.addTo(gridOverlayGroup);
          gridPolygons.push(polygon);
        }
      }
      gridOverlayGroup.addTo(map);
    }

    function updatePosition(pos) {
      const accuracy = pos.coords.accuracy;
      const accuracyDiv = document.querySelector('.accuracy');

      // ç²¾åº¦ã®è©•ä¾¡
      let accuracyText = 'è¦æ³¨æ„';
      if (accuracy <= 10) {
        accuracyText = 'ã¨ã¦ã‚‚è‰¯å¥½';
      } else if (accuracy <= 20) {
        accuracyText = 'æ™®é€š';
      }
      accuracyDiv.textContent = `ç²¾åº¦: ${Math.round(accuracy)}m (${accuracyText})`;

      // ç¾åœ¨ä½ç½®ã¨ã‚°ãƒªãƒƒãƒ‰å·¦ä¸Šã¨ã®ç·¯åº¦çµŒåº¦å·®ã‚’è¨ˆç®—
      const deltaLat = topLeftLat - pos.coords.latitude;
      const deltaLng = pos.coords.longitude - topLeftLng;

      // ã‚°ãƒªãƒƒãƒ‰å†…ã®ã‚»ãƒ«ã®ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹è¨ˆç®—ï¼ˆ0-indexedï¼‰
      const gridY = Math.floor(deltaLat / latDiff);
      const gridX = Math.floor(deltaLng / lngDiff);
      
      // ç¾åœ¨ã®ã‚°ãƒªãƒƒãƒ‰ãƒã‚¸ã‚·ãƒ§ãƒ³ã‚’æ›´æ–°
      currentGridPosition = { x: gridX, y: gridY };

      const positionDiv = document.querySelector('.position');
      if (gridX >= 0 && gridX < GRID_SIZE && gridY >= 0 && gridY < GRID_SIZE) {
        // ãƒ¦ãƒ¼ã‚¶ãƒ¼ã«ã¯1-indexedã§è¡¨ç¤º
        positionDiv.textContent = `ç¾åœ¨ä½ç½®: ã‚°ãƒªãƒƒãƒ‰(${gridX + 1}, ${gridY + 1})`;
        
        // ä½ç½®ãŒå¤‰ã‚ã£ãŸã‚‰ãƒã‚¤ãƒ³ã‚¹ã‚¤ãƒ¼ãƒ‘ãƒ¼ã®ã‚»ãƒ«ã‚’è‡ªå‹•ã§é–‹ã
        if (lastGridPosition.x !== currentGridPosition.x || lastGridPosition.y !== currentGridPosition.y) {
          if (!gameOver && gridX >= 0 && gridX < GRID_SIZE && gridY >= 0 && gridY < GRID_SIZE) {
            revealCell(gridY, gridX);
          }
          lastGridPosition = { ...currentGridPosition };
        }
      } else {
        positionDiv.textContent = `ç¾åœ¨ä½ç½®: ã‚°ãƒªãƒƒãƒ‰å¤–`;
      }

      // ã™ã¹ã¦ã®ã‚»ãƒ«ã‚’åˆæœŸçŠ¶æ…‹ã«ãƒªã‚»ãƒƒãƒˆ
      gridPolygons.forEach(polygon => {
        polygon.setStyle({
          fillOpacity: 0.1,
          fillColor: 'gray'
        });
      });
      // ãƒã‚¤ãƒ©ã‚¤ãƒˆã™ã‚‹ã‚»ãƒ«ã®è‰²ã‚’æ›´æ–°
      if (gridX >= 0 && gridX < GRID_SIZE && gridY >= 0 && gridY < GRID_SIZE) {
        gridPolygons.forEach(polygon => {
          if (polygon.gridX === gridX && polygon.gridY === gridY) {
            // ãƒã‚¤ãƒ³ã‚¹ã‚¤ãƒ¼ãƒ‘ãƒ¼ã®çŠ¶æ…‹ã«å¿œã˜ã¦ã‚»ãƒ«ã®è‰²ã‚’å¤‰æ›´
            let fillColor = 'blue';
            if (gameBoard[gridY][gridX].isMine && gameBoard[gridY][gridX].isRevealed) {
              fillColor = 'red';
            } else if (gameBoard[gridY][gridX].isRevealed) {
              fillColor = 'green';
            } else if (gameBoard[gridY][gridX].isFlagged) {
              fillColor = 'orange';
            }
            
            polygon.setStyle({
              fillOpacity: 0.5,
              fillColor: fillColor
            });
          }
        });
      }

      // ç¾åœ¨ã®ã‚»ãƒ«ã®ä¸­å¤®åº§æ¨™ã‚’è¨ˆç®—
      const cellCenterLat = topLeftLat - (gridY + 0.5) * latDiff;
      const cellCenterLng = topLeftLng + (gridX + 0.5) * lngDiff;

      // ãƒãƒ¼ã‚«ãƒ¼ã®é…ç½®ï¼æ›´æ–°ï¼ˆã‚»ãƒ«ä¸­å¤®ã«è¡¨ç¤ºï¼‰
      if (!updatePosition.marker) {
        updatePosition.marker = L.marker([cellCenterLat, cellCenterLng]).addTo(map);
      } else {
        updatePosition.marker.setLatLng([cellCenterLat, cellCenterLng]);
      }
    }
    
    // ãƒã‚¤ãƒ³ã‚¹ã‚¤ãƒ¼ãƒ‘ãƒ¼é–¢é€£ã®é–¢æ•°
    function initializeMinesweeper() {
      // ã‚²ãƒ¼ãƒ å¤‰æ•°ã®åˆæœŸåŒ–
      mineCount = Math.floor(GRID_SIZE * GRID_SIZE * 0.15); // ã‚°ãƒªãƒƒãƒ‰ã®ç´„15%ã‚’åœ°é›·ã«
      if (mineCount < 10) mineCount = 10; // æœ€ä½10å€‹ã®åœ°é›·
      if (mineCount > 100) mineCount = 100; // æœ€å¤§100å€‹ã®åœ°é›·
      
      flagsUsed = 0;
      gameOver = false;
      cellsRevealed = 0;
      document.getElementById('flagsLeft').textContent = `æ®‹ã‚Šæ——: ${mineCount - flagsUsed}`;
      
      // ã‚°ãƒªãƒƒãƒ‰ã®åˆæœŸåŒ–
      createMinesweeperGrid();
      
      // ã‚¤ãƒ™ãƒ³ãƒˆãƒªã‚¹ãƒŠãƒ¼
      document.getElementById('resetGame').addEventListener('click', initializeMinesweeper);
    }
    
    function createMinesweeperGrid() {
      const gridContainer = document.getElementById('minesweeperGrid');
      gridContainer.innerHTML = '';
      gridContainer.style.gridTemplateColumns = `repeat(${GRID_SIZE}, 30px)`;
      
      // ã‚²ãƒ¼ãƒ ãƒœãƒ¼ãƒ‰ã®åˆæœŸåŒ–
      gameBoard = Array(GRID_SIZE).fill().map(() => 
        Array(GRID_SIZE).fill().map(() => ({
          isMine: false,
          isRevealed: false,
          isFlagged: false,
          adjacentMines: 0
        }))
      );
      
      // åœ°é›·ã®é…ç½®
      mines = [];
      let minesPlaced = 0;
      while (minesPlaced < mineCount) {
        const x = Math.floor(Math.random() * GRID_SIZE);
        const y = Math.floor(Math.random() * GRID_SIZE);
        
        if (!gameBoard[y][x].isMine) {
          gameBoard[y][x].isMine = true;
          mines.push({ x, y });
          minesPlaced++;
        }
      }
      
      // éš£æ¥ã™ã‚‹åœ°é›·æ•°ã®è¨ˆç®—
      for (let y = 0; y < GRID_SIZE; y++) {
        for (let x = 0; x < GRID_SIZE; x++) {
          if (gameBoard[y][x].isMine) continue;
          
          let count = 0;
          // 8æ–¹å‘ã‚’ãƒã‚§ãƒƒã‚¯
          for (let dy = -1; dy <= 1; dy++) {
            for (let dx = -1; dx <= 1; dx++) {
              if (dx === 0 && dy === 0) continue;
              
              const nx = x + dx;
              const ny = y + dy;
              
              if (nx >= 0 && nx < GRID_SIZE && ny >= 0 && ny < GRID_SIZE && gameBoard[ny][nx].isMine) {
                count++;
              }
            }
          }
          gameBoard[y][x].adjacentMines = count;
        }
      }
      
      // UIã®ä½œæˆ
      for (let y = 0; y < GRID_SIZE; y++) {
        for (let x = 0; x < GRID_SIZE; x++) {
          const cell = document.createElement('div');
          cell.classList.add('cell');
          cell.dataset.x = x;
          cell.dataset.y = y;
          
          // å³ã‚¯ãƒªãƒƒã‚¯ã§æ——ã‚’ç«‹ã¦ã‚‹
          cell.addEventListener('contextmenu', (e) => {
            e.preventDefault();
            if (!gameOver && !gameBoard[y][x].isRevealed) {
              toggleFlag(y, x);
            }
          });
          
          // å·¦ã‚¯ãƒªãƒƒã‚¯ã§ã‚»ãƒ«ã‚’é–‹ãï¼ˆãƒ‡ãƒãƒƒã‚°ç”¨ï¼‰
          cell.addEventListener('click', () => {
            if (!gameOver && !gameBoard[y][x].isFlagged) {
              revealCell(y, x);
            }
          });
          
          gridContainer.appendChild(cell);
        }
      }
      
      updateMinesweeperUI();
    }
    
    function revealCell(y, x) {
      // ç¯„å›²å¤–ã€æ—¢ã«é–‹ã„ã¦ã„ã‚‹ã€ã¾ãŸã¯æ——ãŒç«‹ã£ã¦ã„ã‚‹å ´åˆã¯ä½•ã‚‚ã—ãªã„
      if (y < 0 || y >= GRID_SIZE || x < 0 || x >= GRID_SIZE || 
          gameBoard[y][x].isRevealed || gameBoard[y][x].isFlagged) {
        return;
      }
      
      // ã‚»ãƒ«ã‚’é–‹ã
      gameBoard[y][x].isRevealed = true;
      cellsRevealed++;
      
      // åœ°é›·ã‚’è¸ã‚“ã å ´åˆ
      if (gameBoard[y][x].isMine) {
        gameOver = true;
        revealAllMines();
        alert('ã‚²ãƒ¼ãƒ ã‚ªãƒ¼ãƒãƒ¼ï¼åœ°é›·ã‚’è¸ã¿ã¾ã—ãŸã€‚');
        return;
      }
      
      // ç©ºã®ã‚»ãƒ«ï¼ˆéš£æ¥åœ°é›·ãªã—ï¼‰ã®å ´åˆã¯å‘¨å›²ã‚’å†å¸°çš„ã«é–‹ã
      if (gameBoard[y][x].adjacentMines === 0) {
        for (let dy = -1; dy <= 1; dy++) {
          for (let dx = -1; dx <= 1; dx++) {
            if (dx === 0 && dy === 0) continue;
            revealCell(y + dy, x + dx);
          }
        }
      }
      
      // å‹åˆ©æ¡ä»¶ãƒã‚§ãƒƒã‚¯: åœ°é›·ä»¥å¤–ã®ã™ã¹ã¦ã®ã‚»ãƒ«ãŒé–‹ã‹ã‚ŒãŸã‹
      if (cellsRevealed === GRID_SIZE * GRID_SIZE - mineCount && !gameOver) {
        gameOver = true;
        // ã™ã¹ã¦ã®åœ°é›·ã«æ——ã‚’ç«‹ã¦ã‚‹
        for (const mine of mines) {
          if (!gameBoard[mine.y][mine.x].isFlagged) {
            gameBoard[mine.y][mine.x].isFlagged = true;
            flagsUsed++;
          }
        }
        alert('ãŠã‚ã§ã¨ã†ã”ã–ã„ã¾ã™ï¼ã™ã¹ã¦ã®å®‰å…¨ãªãƒã‚¹ã‚’é–‹ãã¾ã—ãŸã€‚');
      }
      
      updateMinesweeperUI();
    }
    
    function toggleFlag(y, x) {
      if (gameBoard[y][x].isFlagged) {
        // æ——ã‚’å¤–ã™
        gameBoard[y][x].isFlagged = false;
        flagsUsed--;
      } else if (flagsUsed < mineCount) {
        // æ——ã‚’ç«‹ã¦ã‚‹ï¼ˆæ®‹ã‚Šæ——ãŒã‚ã‚‹å ´åˆï¼‰
        gameBoard[y][x].isFlagged = true;
        flagsUsed++;
      }
      
      document.getElementById('flagsLeft').textContent = `æ®‹ã‚Šæ——: ${mineCount - flagsUsed}`;
      updateMinesweeperUI();
    }
    
    function revealAllMines() {
      for (const mine of mines) {
        gameBoard[mine.y][mine.x].isRevealed = true;
      }
      updateMinesweeperUI();
    }
    
    function updateMinesweeperUI() {
      const cells = document.querySelectorAll('.cell');
      
      cells.forEach(cell => {
        const x = parseInt(cell.dataset.x);
        const y = parseInt(cell.dataset.y);
        const cellData = gameBoard[y][x];
        
        // ã‚»ãƒ«ã®ã‚¯ãƒ©ã‚¹ã‚’ãƒªã‚»ãƒƒãƒˆ
        cell.className = 'cell';
        cell.textContent = '';
        
        if (cellData.isRevealed) {
          cell.classList.add('revealed');
          
          if (cellData.isMine) {
            cell.classList.add('mine');
            cell.textContent = 'ğŸ’£';
          } else if (cellData.adjacentMines > 0) {
            cell.textContent = cellData.adjacentMines;
            cell.classList.add(`number-${cellData.adjacentMines}`);
          }
        } else if (cellData.isFlagged) {
          cell.textContent = 'ğŸš©';
        }
        
        // ç¾åœ¨ä½ç½®ã®ã‚»ãƒ«ã‚’ãƒã‚¤ãƒ©ã‚¤ãƒˆ
        if (currentGridPosition.x === x && currentGridPosition.y === y) {
          cell.style.border = '2px solid blue';
        } else {
          cell.style.border = '1px solid #999';
        }
      });
      
      document.getElementById('flagsLeft').textContent = `æ®‹ã‚Šæ——: ${mineCount - flagsUsed}`;
    }
  </script>
</body>
</html>