<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>暫定グリッド表示＆マインスイーパーゲーム（Marker常時表示）</title>
  <!-- LeafletのCSS -->
  <link rel="stylesheet" href="https://unpkg.com/leaflet/dist/leaflet.css" />
  <style>
    body { margin: 0; padding: 0; }
    #map { height: 400px; }
    .controls, .game-controls { margin: 10px; }
    .accuracy, .position { margin: 10px; }
  </style>
</head>
<body>
  <div class="controls">
    <label for="cellSizeSelect">セルサイズ (m):</label>
    <select id="cellSizeSelect">
      <option value="30">30</option>
      <option value="60">60</option>
      <option value="100" selected>100</option>
      <option value="500">500</option>
      <option value="1000">1000</option>
    </select>

    <label for="gridSizeSelect">グリッドサイズ:</label>
    <select id="gridSizeSelect">
      <option value="9" selected>9×9</option>
      <option value="17">17×17</option>
      <option value="31">31×31</option>
    </select>

    <button id="getLocationButton" onclick="getLocation()">場所を取得</button>
    <button id="startGridButton" onclick="startGrid()" disabled>グリッド開始</button>
  </div>

  <!-- ゲーム操作用ボタン（グリッド固定後に表示） -->
  <div class="game-controls" id="gameControls" style="display:none;">
    <button onclick="actionFlag()">旗を立てる</button>
    <button onclick="actionOpen()">開く</button>
  </div>

  <div class="accuracy"></div>
  <div id="map"></div>
  <div class="position"></div>

  <!-- LeafletのJS -->
  <script src="https://unpkg.com/leaflet/dist/leaflet.js"></script>
  <script>
    let basePosition = null;         // 取得した位置情報
    let map;
    let gridOverlayGroup = L.layerGroup(); // グリッド描画用レイヤーグループ
    let CELL_SIZE, GRID_SIZE;        // セルサイズとグリッドサイズ（select boxの値）
    const gridPolygons = [];         // 各セルのポリゴンを保存する配列
    let topLeftLat, topLeftLng, latDiff, lngDiff; // グリッド描画用の計算値
    let watchId = null;              // 位置監視のID
    let gridFixed = false;           // グリッドが固定されたかどうかのフラグ
    let currentCell = null;          // プレイヤーが現在いるセル

    // ページ読み込み時にデフォルトの地図を表示（例：東京）
    window.addEventListener("DOMContentLoaded", function() {
      map = L.map('map').setView([35.6895, 139.6917], 10);
      L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
        attribution: '© OpenStreetMap contributors'
      }).addTo(map);
      gridOverlayGroup.addTo(map);

      // select boxの変更で暫定グリッド更新
      document.getElementById('cellSizeSelect').addEventListener('change', updateTentativeGrid);
      document.getElementById('gridSizeSelect').addEventListener('change', updateTentativeGrid);
    });

    // 「場所を取得」ボタン押下時
    function getLocation() {
      const getLocationButton = document.getElementById('getLocationButton');
      getLocationButton.textContent = "位置情報取得中...";
      getLocationButton.disabled = true;

      if ("geolocation" in navigator) {
        navigator.geolocation.getCurrentPosition(pos => {
          basePosition = {
            lat: pos.coords.latitude,
            lng: pos.coords.longitude
          };
          // 地図の中心更新（ズームレベル19）
          map.setView([basePosition.lat, basePosition.lng], 19);

          getLocationButton.textContent = "場所取得済み";
          document.getElementById('startGridButton').disabled = false;
          // 暫定グリッド表示
          updateTentativeGrid();

          // 位置監視を開始（グリッド固定前もMarker更新のために起動）
          if (watchId === null) {
            watchId = navigator.geolocation.watchPosition(updatePosition, null, {
              enableHighAccuracy: true,
              timeout: 5000,
              maximumAge: 0
            });
          }
        }, err => {
          getLocationButton.textContent = "取得失敗";
          console.error(err);
        });
      }
    }

    // 暫定グリッド更新（グリッド固定前）
    function updateTentativeGrid() {
      if (!basePosition || gridFixed) return;
      
      CELL_SIZE = parseInt(document.getElementById('cellSizeSelect').value, 10);
      GRID_SIZE = parseInt(document.getElementById('gridSizeSelect').value, 10);
      
      const metersPerDegree = 111320;
      latDiff = CELL_SIZE / metersPerDegree;
      lngDiff = CELL_SIZE / (metersPerDegree * Math.cos(basePosition.lat * Math.PI / 180));

      const centerIndex = (GRID_SIZE - 1) / 2;
      topLeftLat = basePosition.lat + (centerIndex + 0.5) * latDiff;
      topLeftLng = basePosition.lng - (centerIndex + 0.5) * lngDiff;

      drawGridOverlay();
    }

    // 「グリッド開始」ボタン押下時（グリッド固定＆ゲーム開始）
    function startGrid() {
      gridFixed = true;
      document.getElementById('cellSizeSelect').disabled = true;
      document.getElementById('gridSizeSelect').disabled = true;
      document.getElementById('startGridButton').disabled = true;
      // 固定時点のグリッド再描画
      updateTentativeGrid();
      // マインスイーパー操作用のボタン表示
      document.getElementById('gameControls').style.display = 'block';
    }

    // グリッド描画
    function drawGridOverlay() {
      gridOverlayGroup.clearLayers();
      gridPolygons.length = 0;

      for (let i = 0; i < GRID_SIZE; i++) {
        for (let j = 0; j < GRID_SIZE; j++) {
          const bounds = [
            [topLeftLat - i * latDiff,       topLeftLng + j * lngDiff],
            [topLeftLat - i * latDiff,       topLeftLng + (j + 1) * lngDiff],
            [topLeftLat - (i + 1) * latDiff, topLeftLng + (j + 1) * lngDiff],
            [topLeftLat - (i + 1) * latDiff, topLeftLng + j * lngDiff]
          ];
          const polygon = L.polygon(bounds, {
            color: 'black',
            weight: 1,
            fillOpacity: 0.1,
            fillColor: 'gray'
          });
          polygon.gridX = j;
          polygon.gridY = i;
          // マインスイーパー用の状態（初期状態）
          polygon.isOpened = false;
          polygon.isFlagged = false;
          polygon.addTo(gridOverlayGroup);
          gridPolygons.push(polygon);
        }
      }
    }

    // 位置更新時の処理
    function updatePosition(pos) {
      const accuracy = pos.coords.accuracy;
      const accuracyDiv = document.querySelector('.accuracy');
      let accuracyText = '要注意';
      if (accuracy <= 10) {
        accuracyText = 'とても良好';
      } else if (accuracy <= 20) {
        accuracyText = '普通';
      }
      accuracyDiv.textContent = `精度: ${Math.round(accuracy)}m (${accuracyText})`;

      // 現在位置とグリッド左上との差
      const deltaLat = topLeftLat - pos.coords.latitude;
      const deltaLng = pos.coords.longitude - topLeftLng;
      const gridY = Math.floor(deltaLat / latDiff);
      const gridX = Math.floor(deltaLng / lngDiff);

      const positionDiv = document.querySelector('.position');
      if (gridX >= 0 && gridX < GRID_SIZE && gridY >= 0 && gridY < GRID_SIZE) {
        positionDiv.textContent = `現在位置: グリッド(${gridX + 1}, ${gridY + 1})`;
      } else {
        positionDiv.textContent = `現在位置: グリッド外`;
      }

      // ハイライト更新（グリッド固定前は暫定表示としてのみ利用）
      gridPolygons.forEach(polygon => {
        // 既に開かれているセルは状態を維持
        if (!polygon.isOpened && !polygon.isFlagged) {
          polygon.setStyle({ fillOpacity: 0.1, fillColor: 'gray' });
        }
      });
      currentCell = null;
      if (gridX >= 0 && gridX < GRID_SIZE && gridY >= 0 && gridY < GRID_SIZE) {
        gridPolygons.forEach(polygon => {
          if (polygon.gridX === gridX && polygon.gridY === gridY) {
            if (!polygon.isOpened && !polygon.isFlagged) {
              polygon.setStyle({ fillOpacity: 0.5, fillColor: 'blue' });
            }
            currentCell = polygon;
          }
        });
      }
      
      // Markerの表示／更新
      // グリッドが確定していればセル中心、暫定なら現在の位置にMarkerを表示
      let markerLat, markerLng;
      if (gridFixed && currentCell) {
        markerLat = topLeftLat - (currentCell.gridY + 0.5) * latDiff;
        markerLng = topLeftLng + (currentCell.gridX + 0.5) * lngDiff;
      } else {
        markerLat = pos.coords.latitude;
        markerLng = pos.coords.longitude;
      }
      if (!updatePosition.marker) {
        updatePosition.marker = L.marker([markerLat, markerLng]).addTo(map);
      } else {
        updatePosition.marker.setLatLng([markerLat, markerLng]);
      }
    }

    // マインスイーパー操作：旗を立てる
    function actionFlag() {
      if (!currentCell) return;
      if (currentCell.isOpened) return;
      currentCell.isFlagged = !currentCell.isFlagged;
      if (currentCell.isFlagged) {
        currentCell.setStyle({ fillOpacity: 0.7, fillColor: 'red' });
      } else {
        currentCell.setStyle({ fillOpacity: 0.5, fillColor: 'blue' });
      }
    }

    // マインスイーパー操作：セルを開く
    function actionOpen() {
      if (!currentCell) return;
      if (currentCell.isFlagged) return;
      currentCell.isOpened = true;
      currentCell.setStyle({ fillOpacity: 0.9, fillColor: 'white' });
    }
  </script>
</body>
</html>
