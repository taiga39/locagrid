<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>位置測定マインスイーパー（改良版：自分の位置は黄色）</title>
  <link rel="stylesheet" href="https://unpkg.com/leaflet/dist/leaflet.css" />
  <style>
    body { margin: 0; padding: 0; }
    #map { height: 400px; }
    .controls { margin: 10px; }
    .accuracy, .position { margin: 10px; }
    .game-controls { 
      margin: 10px; 
      display: none;
    }
    .reset-controls {
      margin: 10px;
      display: none;
    }
    /* 下部マインスイーパーグリッド */
    #minesweeperGrid {
      display: block;
      margin: 20px auto;
      width: fit-content;
    }
    .grid-row {
      display: flex;
    }
    .grid-cell {
      width: 30px;
      height: 30px;
      border: 1px solid #999;
      display: flex;
      align-items: center;
      justify-content: center;
      font-weight: bold;
      background-color: #ddd;
    }
    .revealed {
      background-color: rgba(255,255,255,0.5);
    }
    .mine {
      background-color: #f88;
    }
    .flagged {
      background-color: #faa;
    }
    .current-position {
      background-color: yellow !important;
      border: 2px solid gold;
    }
    .number-1 { color: blue; }
    .number-2 { color: green; }
    .number-3 { color: red; }
    .number-4 { color: darkblue; }
    .number-5 { color: darkred; }
    .number-6 { color: darkcyan; }
    .number-7 { color: black; }
    .number-8 { color: gray; }
  </style>
</head>
<body>
  <div class="controls">
    <label for="cellSizeSelect">セルサイズ (m):</label>
    <select id="cellSizeSelect">
      <option value="30">30</option>
      <option value="60">60</option>
      <option value="100" selected>100</option>
      <option value="500">500</option>
      <option value="1000">1000</option>
    </select>

    <label for="gridSizeSelect">グリッドサイズ:</label>
    <select id="gridSizeSelect">
      <option value="9" selected>9×9</option>
      <option value="17">17×17</option>
      <option value="31">31×31</option>
    </select>

    <button id="getLocationButton" onclick="getLocation()">現在地を取得</button>
    <button id="startGridButton" onclick="startGrid()" disabled>ゲームを開始</button>
  </div>

  <div class="accuracy"></div>
  <div id="map"></div>
  <div class="position"></div>
  
  <!-- ゲーム操作ボタン -->
  <div class="game-controls" id="gameControls">
    <button id="flagButton" disabled>旗を立てる</button>
    <button id="openButton" onclick="actionOpen()">開く</button>
  </div>

  <!-- リセットボタン -->
  <div class="reset-controls" id="resetControls">
    <button id="resetButton" onclick="resetGame()">リセット</button>
  </div>

  <!-- 下部グリッド -->
  <div id="minesweeperGrid"></div>

  <!-- Leaflet -->
  <script src="https://unpkg.com/leaflet/dist/leaflet.js"></script>
  <script>
    // URLパラメータのチェック（デバッグモード）
    const urlParams = new URLSearchParams(window.location.search);
    const debugMode = urlParams.get('debug') === 'true';

    // グローバル変数
    let basePosition = null;
    let map;
    let gridOverlayGroup = L.layerGroup();
    let CELL_SIZE, GRID_SIZE;
    const gridPolygons = [];
    let topLeftLat, topLeftLng, latDiff, lngDiff;
    let watchId = null;
    let gridFixed = false;
    let currentCell = null;
    
    // マインスイーパー用変数
    let mines = [];
    let mineCount = 0;
    let flagsUsed = 0;
    let gameOver = false;
    let gameWon = false;
    let cellsRevealed = 0;
    let minesInitialized = false; // 最初のクリックで地雷配置
    const flagButton = document.getElementById('flagButton');
    const openButton = document.getElementById('openButton');

    // ページロード時に地図を初期表示
    window.addEventListener("DOMContentLoaded", function() {
      map = L.map('map').setView([35.6895, 139.6917], 10);
      L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
        attribution: '© OpenStreetMap contributors'
      }).addTo(map);
      gridOverlayGroup.addTo(map);

      document.getElementById('cellSizeSelect').addEventListener('change', updateTentativeGrid);
      document.getElementById('gridSizeSelect').addEventListener('change', updateTentativeGrid);

      // 旗ボタンクリックイベント
      flagButton.addEventListener('click', actionFlag);
    });

    // 「現在地を取得」ボタン
    function getLocation() {
      const getLocationButton = document.getElementById('getLocationButton');
      getLocationButton.textContent = "位置情報取得中...";
      getLocationButton.disabled = true;

      if ("geolocation" in navigator) {
        navigator.geolocation.getCurrentPosition(pos => {
          basePosition = { lat: pos.coords.latitude, lng: pos.coords.longitude };
          map.setView([basePosition.lat, basePosition.lng], 19);

          getLocationButton.textContent = "場所取得済み";
          document.getElementById('startGridButton').disabled = false;
          
          // 暫定グリッド表示
          updateTentativeGrid();
          
          // 位置監視開始（Marker更新のため）
          if (watchId === null) {
            watchId = navigator.geolocation.watchPosition(updatePosition, null, {
              enableHighAccuracy: true,
              timeout: 5000,
              maximumAge: 0
            });
          }
        }, err => {
          getLocationButton.textContent = "取得失敗";
          console.error(err);
        });
      }
    }

    // 暫定グリッド更新
    function updateTentativeGrid() {
      if (!basePosition || gridFixed) return;
      
      CELL_SIZE = parseInt(document.getElementById('cellSizeSelect').value, 10);
      GRID_SIZE = parseInt(document.getElementById('gridSizeSelect').value, 10);
      
      const metersPerDegree = 111320;
      latDiff = CELL_SIZE / metersPerDegree;
      lngDiff = CELL_SIZE / (metersPerDegree * Math.cos(basePosition.lat * Math.PI / 180));

      const centerIndex = (GRID_SIZE - 1) / 2;
      topLeftLat = basePosition.lat + (centerIndex + 0.5) * latDiff;
      topLeftLng = basePosition.lng - (centerIndex + 0.5) * lngDiff;

      drawGridOverlay();
    }

    // グリッドオーバーレイ
    function drawGridOverlay() {
      gridOverlayGroup.clearLayers();
      gridPolygons.length = 0;

      for (let i = 0; i < GRID_SIZE; i++) {
        for (let j = 0; j < GRID_SIZE; j++) {
          const bounds = [
            [topLeftLat - i * latDiff, topLeftLng + j * lngDiff],
            [topLeftLat - i * latDiff, topLeftLng + (j+1)*lngDiff],
            [topLeftLat - (i+1)*latDiff, topLeftLng + (j+1)*lngDiff],
            [topLeftLat - (i+1)*latDiff, topLeftLng + j*lngDiff]
          ];
          const polygon = L.polygon(bounds, {
            color: 'black',
            weight: 1,
            fillOpacity: 0.1,
            fillColor: 'gray'
          });
          polygon.gridX = j;
          polygon.gridY = i;
          polygon.isRevealed = false;
          polygon.isFlagged = false;
          polygon.isMine = false;
          polygon.adjacentMines = 0;
          polygon.addTo(gridOverlayGroup);
          gridPolygons.push(polygon);
        }
      }
    }

    // ゲーム開始ボタン
    function startGrid() {
      gridFixed = true;
      document.getElementById('cellSizeSelect').disabled = true;
      document.getElementById('gridSizeSelect').disabled = true;
      document.getElementById('startGridButton').disabled = true;

      document.getElementById('gameControls').style.display = 'block';

      createMinesweeperGridUI();
    }

    // 位置更新
    function updatePosition(pos) {
      const accuracy = pos.coords.accuracy;
      const accuracyDiv = document.querySelector('.accuracy');
      let accuracyText = '要注意';
      if (accuracy <= 10) {
        accuracyText = 'とても良好';
      } else if (accuracy <= 20) {
        accuracyText = '普通';
      }
      accuracyDiv.textContent = `精度: ${Math.round(accuracy)}m (${accuracyText})`;

      const deltaLat = topLeftLat - pos.coords.latitude;
      const deltaLng = pos.coords.longitude - topLeftLng;
      const gridY = Math.floor(deltaLat / latDiff);
      const gridX = Math.floor(deltaLng / lngDiff);

      const positionDiv = document.querySelector('.position');
      if (gridX >= 0 && gridX < GRID_SIZE && gridY >= 0 && gridY < GRID_SIZE) {
        positionDiv.textContent = `現在位置: グリッド(${gridX + 1}, ${gridY + 1})`;
      } else {
        positionDiv.textContent = `現在位置: グリッド外`;
      }

      // 全セル（未開封＆非旗）を灰色に戻す
      gridPolygons.forEach(poly => {
        if (!poly.isRevealed && !poly.isFlagged) {
          poly.setStyle({
            fillColor: 'gray',
            fillOpacity: 0.1
          });
        }
      });

      let oldCell = currentCell;
      currentCell = null;
      if (gridX >= 0 && gridX < GRID_SIZE && gridY >= 0 && gridY < GRID_SIZE) {
        const index = gridY * GRID_SIZE + gridX;
        currentCell = gridPolygons[index];

        // 現在地セルが未開封・未旗なら黄色
        if (gridFixed && !gameOver && !currentCell.isRevealed && !currentCell.isFlagged) {
          currentCell.setStyle({
            fillColor: 'yellow',
            fillOpacity: 0.5
          });
        }
      }

      if (gridFixed && (oldCell !== currentCell)) {
        updateMinesweeperGridUI();
      }

      // マーカー
      let markerLat, markerLng;
      if (gridFixed && currentCell) {
        markerLat = topLeftLat - (currentCell.gridY + 0.5) * latDiff;
        markerLng = topLeftLng + (currentCell.gridX + 0.5) * lngDiff;
      } else {
        markerLat = pos.coords.latitude;
        markerLng = pos.coords.longitude;
      }
      if (!updatePosition.marker) {
        updatePosition.marker = L.marker([markerLat, markerLng]).addTo(map);
      } else {
        updatePosition.marker.setLatLng([markerLat, markerLng]);
      }
    }

    // 下部グリッドUI作成
    function createMinesweeperGridUI() {
      const container = document.getElementById('minesweeperGrid');
      container.innerHTML = '';
      
      for (let y = 0; y < GRID_SIZE; y++) {
        const rowDiv = document.createElement('div');
        rowDiv.className = 'grid-row';
        for (let x = 0; x < GRID_SIZE; x++) {
          const cellDiv = document.createElement('div');
          cellDiv.className = 'grid-cell';
          cellDiv.dataset.x = x;
          cellDiv.dataset.y = y;
          if (debugMode) {
            // デバッグモード: セルクリックで開けるテスト
            cellDiv.addEventListener('click', () => {
              if (gameOver) return;
              const idx = y * GRID_SIZE + x;
              const p = gridPolygons[idx];
              if (p.isRevealed || p.isFlagged) return;
              if (!minesInitialized) {
                initializeMinesweeperGame(x, y);
                minesInitialized = true;
              }
              revealCell(p);
              if (p.isMine) {
                gameOver = true;
                revealAllMines();
                updateMinesweeperGridUI();
                document.getElementById('resetControls').style.display = 'block';
                return;
              }
              if (p.adjacentMines === 0) {
                revealAdjacentCells(y, x);
              }
              updateMinesweeperGridUI();
              checkWinCondition();
            });
          }
          rowDiv.appendChild(cellDiv);
        }
        container.appendChild(rowDiv);
      }
      updateMinesweeperGridUI();
    }

    // 下部グリッドUIの更新
    function updateMinesweeperGridUI() {
      if (!gridFixed) return;

      const cells = document.querySelectorAll('.grid-cell');
      cells.forEach(cell => {
        const x = parseInt(cell.dataset.x, 10);
        const y = parseInt(cell.dataset.y, 10);
        const index = y * GRID_SIZE + x;
        const polygon = gridPolygons[index];

        cell.className = 'grid-cell';
        cell.textContent = '';

        // 現在地表示
        if (currentCell && currentCell.gridX === x && currentCell.gridY === y) {
          cell.classList.add('current-position');
        }

        // 開いているセル
        if (polygon.isRevealed) {
          cell.classList.add('revealed');
          if (polygon.isMine) {
            cell.classList.add('mine');
            cell.textContent = '💣';
          } else if (polygon.adjacentMines > 0) {
            cell.textContent = polygon.adjacentMines;
            cell.classList.add(`number-${polygon.adjacentMines}`);
          }
        }
        // フラグ
        else if (polygon.isFlagged) {
          cell.classList.add('flagged');
          cell.textContent = '🚩';
        }
      });

      // 旗ボタンの文言を動的に変える
      if (!currentCell || currentCell.isRevealed || gameOver) {
        // そのセルでフラグ操作できない場合 → 一旦「旗を立てる」に戻す or 無効化
        flagButton.textContent = "旗を立てる";
        flagButton.disabled = true;
      } else {
        // 未開封セル：フラグ可能
        // ただし、まだ一つもセルを開いてなければ disable
        if (cellsRevealed === 0) {
          flagButton.disabled = true; // 一度も開いてない → 旗不可
        } else {
          flagButton.disabled = false;
        }

        // フラグありなら「旗を消す」、なしなら「旗を立てる」
        if (currentCell.isFlagged) {
          flagButton.textContent = "旗を消す";
        } else {
          flagButton.textContent = "旗を立てる";
        }
      }
    }

    // 旗ボタン押下
    function actionFlag() {
      if (!gridFixed || !currentCell || gameOver || currentCell.isRevealed) return;

      // フラグ ON/OFF
      currentCell.isFlagged = !currentCell.isFlagged;
      if (currentCell.isFlagged) {
        currentCell.setStyle({ fillOpacity: 0.5, fillColor: 'red' });
        flagsUsed++;
      } else {
        // 外したら自分のセルは黄色（未開封なら）
        currentCell.setStyle({ fillOpacity: 0.5, fillColor: 'yellow' });
        flagsUsed--;
      }

      updateMinesweeperGridUI();
      checkWinCondition();
    }

    // セルを開く
    function actionOpen() {
      if (!gridFixed || !currentCell || gameOver || currentCell.isRevealed || currentCell.isFlagged) return;

      // 初回開封で地雷配置
      if (!minesInitialized) {
        initializeMinesweeperGame(currentCell.gridX, currentCell.gridY);
        minesInitialized = true;
      }

      revealCell(currentCell);
      if (currentCell.isMine) {
        gameOver = true;
        revealAllMines();
        updateMinesweeperGridUI();
        document.getElementById('resetControls').style.display = 'block';
        return;
      }
      if (currentCell.adjacentMines === 0) {
        revealAdjacentCells(currentCell.gridY, currentCell.gridX);
      }
      updateMinesweeperGridUI();
      checkWinCondition();
    }

    // セル開封
    function revealCell(cell) {
      if (cell.isRevealed || cell.isFlagged) return;
      cell.isRevealed = true;
      cellsRevealed++;

      // 「初めてセルを開いたら、旗ボタンを有効化」
      if (cellsRevealed === 1) {
        // 同じタイミングで updateMinesweeperGridUI() を呼ぶため、
        // disable 解除のフローはそちらに任せてもOK
      }

      if (cell.isMine) {
        cell.setStyle({ fillOpacity: 0.5, fillColor: '#ff0000' });
      } else {
        if (cell.adjacentMines === 0) {
          cell.setStyle({ fillOpacity: 0.5, fillColor: 'rgba(255,255,255,0.5)' });
        } else {
          const colors = [
            'rgba(255,255,255,0.5)', '#0000ff', '#008000', '#ff0000',
            '#000080', '#800000', '#008080', '#000000', '#808080'
          ];
          cell.setStyle({ fillOpacity: 0.5, fillColor: colors[cell.adjacentMines] });
        }
      }
    }

    // 周囲を自動開封
    function revealAdjacentCells(row, col) {
      for (let dy = -1; dy <= 1; dy++) {
        for (let dx = -1; dx <= 1; dx++) {
          if (dy===0 && dx===0) continue;
          const ny = row + dy, nx = col + dx;
          if (ny<0 || ny>=GRID_SIZE || nx<0 || nx>=GRID_SIZE) continue;
          const idx = ny*GRID_SIZE + nx;
          const nCell = gridPolygons[idx];
          if (!nCell.isRevealed && !nCell.isFlagged) {
            revealCell(nCell);
            if (!nCell.isMine && nCell.adjacentMines === 0) {
              revealAdjacentCells(ny, nx);
            }
          }
        }
      }
    }

    // 地雷配置
    function initializeMinesweeperGame(firstX, firstY) {
      mineCount = Math.floor(GRID_SIZE * GRID_SIZE * 0.15);
      if (mineCount < 10) mineCount = 10;
      if (mineCount > 100) mineCount = 100;
      
      flagsUsed = 0;
      gameOver = false;
      gameWon = false;
      cellsRevealed = 0;
      mines = [];
      
      let minesPlaced = 0;
      
      // 安全域
      const safeZone = [];
      for (let dy = -1; dy <= 1; dy++) {
        for (let dx = -1; dx <= 1; dx++) {
          safeZone.push({ x: firstX + dx, y: firstY + dy });
        }
      }
      
      while (minesPlaced < mineCount) {
        const rx = Math.floor(Math.random() * GRID_SIZE);
        const ry = Math.floor(Math.random() * GRID_SIZE);
        if (safeZone.some(pos => pos.x===rx && pos.y===ry)) continue;
        const idx = ry*GRID_SIZE + rx;
        if (!gridPolygons[idx].isMine) {
          gridPolygons[idx].isMine = true;
          mines.push({ x: rx, y: ry });
          minesPlaced++;
        }
      }

      // 隣接地雷数
      for (let r = 0; r < GRID_SIZE; r++) {
        for (let c = 0; c < GRID_SIZE; c++) {
          const idx = r*GRID_SIZE + c;
          if (gridPolygons[idx].isMine) continue;
          let count = 0;
          for (let dy=-1; dy<=1; dy++) {
            for (let dx=-1; dx<=1; dx++) {
              if (dy===0 && dx===0) continue;
              const nr = r+dy, nc = c+dx;
              if (nr<0||nr>=GRID_SIZE||nc<0||nc>=GRID_SIZE) continue;
              const nIdx = nr*GRID_SIZE + nc;
              if (gridPolygons[nIdx].isMine) count++;
            }
          }
          gridPolygons[idx].adjacentMines = count;
        }
      }
    }

    // 全地雷表示
    function revealAllMines() {
      mines.forEach(m => {
        const idx = m.y*GRID_SIZE + m.x;
        const mineCell = gridPolygons[idx];
        if (!mineCell.isFlagged) {
          mineCell.setStyle({
            fillOpacity: 0.5,
            fillColor: '#ff0000'
          });
        }
      });
    }

    // 勝利判定
    function checkWinCondition() {
      const totalCells = GRID_SIZE * GRID_SIZE;
      const nonMineCells = totalCells - mineCount;

      let correctFlags = 0;
      mines.forEach(m => {
        const idx = m.y*GRID_SIZE + m.x;
        if (gridPolygons[idx].isFlagged) {
          correctFlags++;
        }
      });

      // 全非地雷セルを開いた or 全地雷に旗
      if (cellsRevealed === nonMineCells || correctFlags === mineCount) {
        gameWon = true;
        gameOver = true;
        // 未フラグ地雷に旗をつける
        mines.forEach(m => {
          const idx = m.y*GRID_SIZE + m.x;
          if (!gridPolygons[idx].isFlagged) {
            gridPolygons[idx].isFlagged = true;
            flagsUsed++;
          }
        });
        updateMinesweeperGridUI();
        document.getElementById('resetControls').style.display = 'block';
      }
    }

    // リセット
    function resetGame() {
      gameOver = false;
      gameWon = false;
      minesInitialized = false;
      cellsRevealed = 0;
      mineCount = 0;
      flagsUsed = 0;
      mines = [];

      gridPolygons.forEach(p => {
        p.isMine = false;
        p.isFlagged = false;
        p.isRevealed = false;
        p.adjacentMines = 0;
        p.setStyle({
          color: 'black',
          weight: 1,
          fillOpacity: 0.1,
          fillColor: 'gray'
        });
      });

      document.getElementById('resetControls').style.display = 'none';
      updateMinesweeperGridUI();
    }
  </script>
</body>
</html>
